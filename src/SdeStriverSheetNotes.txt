*******************************************************************************************************
Day 1: Arrays
*******************************************************************************************************

Problem 1: - Set Matrix Zeroes :

- Use row zero and column zero for indexing. Use boolean flag for handling zeroes in zeroth column (Because it is responsible for row change as well).

row for loop i(This will set indexing as per each matrix value):
- Check for each row zeroth column (matrix[i][0] == 0), if it contains zero then set the boolean flag.
column for loop j:
- Iterate through each matrix co-ordinate with column looping start with 1, if matrix[i][j] == 0 then set corresponding row zero and column zero as 0, otherwise move ahead.

Indexes are set. Now, Start setting zeroes: -

Two backward for loop i(row - 1 till 0) & j(column - 1 till 1):
- **Start setting zeroes from last element of matrix in order to avoid the change in value at (0,0)**
- Iterate through each matrix co-ordinate, check if corresponding row zero and column zero is 0 (matrix[i][0] == 0 || matrix[0][j] == 0) then set that coordinate as zero (matrix[i][j] = 0) otherwise move backward until column 1.
- Outside column for loop j, check for flag if its set as true then change the column zero of that row as 0 (matrix[i][0] = 0;), otherwise move to next iteration.

-------------------------------------------------------------------------------------------------------

Problem 2: - Pascals triangle : (return List<List<Integer>>)

- Create 3 Lists : List<List<Integer>> res & List<Integer> row, prev(to point out previous row)

for loop i(handle each row):
- intialize list row
for loop j(from 0 till i) -> handle column for that particular row :
- first & last column value will be 1 (j == 0 || j == i), add 1 to the row else,
- perform sum from prev list, taking j - 1 and jth element (row.add(prev.get(j - 1) + prev.get(j)))

outside for loop j:
- assign row to prev.
- Add row to res list.

-------------------------------------------------------------------------------------------------------

Problem 3: - Next Permutation:

Intution with steps: -
- From back there is an increasing sequence even for 1 element or more than 1 element. So, humko break point dhundhna hai from the back where a[i] < a[i + 1].
Step 1: - Get index i from back where a[i] < a[i + 1] -> Code me ulta condition lagaenge

- Now, we want someone from back again jo current i se jyada ho to arrange in lower rank of sorted order.
Step 2: - Get index j from back where a[j] > a[i] -> Code me ulta condition lagaenge

- Swap i and j to arrange in lower rank
Step 3: - Swap index i and j

- Reverse krenge i+1 se end tak in increasing order which will again ensure lower rank of sorted  order
Step 4: - Reverse string from i + 1 to length - 1

-------------------------------------------------------------------------------------------------------

Problem 4: - Kadane's algorithm (Maximum subarray):

1. Initialize sum = 0 & maxSum = first element of array.
2. Iterate through each element of an array and add it to sum variable.
3. 2 if statements: -
	a. Check if sum > maxSum then maxSum = sum;
	b. check if sum < 0 then sum = 0; //Reason: Adding on consecutive -ve values will lower down the sum value so no point having sum as -ve number hence re-assign it to 0.
4. Return maxSum;

-------------------------------------------------------------------------------------------------------

Problem 5: - Sort an array of 0's, 1's & 2's (Dutch National flag algorithm is used to sort this in O(N) TC.):

Intution: -
- [0 ... low -1] -> 0 (Left side of low pointer will contains 0's)
- [high + 1 ... n] -> 2 (Right side of high pointer will contains 2's)

Steps: -
1. Maintain 3 pointers : low, mid, high -> low = mid = 0; high = size - 1
while(mid <= high) then switch (nums[mid]){}
2. If mid finds value as 0 -> Swap low with mid & increment both low & mid pointer
3. If mid finds value as 1 -> Just increment mid pointer
4. If mid finds value as 2 -> Swap high with mid & decrement high pointer

-------------------------------------------------------------------------------------------------------

Problem 6: - Buy and sell stock:

1. Initialize min = prices[0] and maxProfit = 0;
2. Loop over each element and check if min > prices[i] then assign min = prices[i], ELSE IF
3. Check if (prices[i] - min > maxProfit) then assign maxProfit as prices[i] - min within same for loop.
4. Return maxProfit.

-------------------------------------------------------------------------------------------------------

*******************************************************************************************************

Day 2: Arrays Part - II

*******************************************************************************************************

Problem 1: - Rotate Matrix:

-> Intuition: If you see row in rotated output matrix, it is reverse of column

1. Find transpose of a matrix -> Transpose: Column becomes row & row becomes column
	a. for loop i (0 -> matrix.length) and for loop j (i -> matrix.length) 	(Here j = i because 1st row and 1st column is already transposed. In next iteration, we don't have to start with previous column otherwise values again get swapped.)
	b. Swap values by using temp and matrix[i][j] = matrix[j][i];

2. reverse each row of a matrix
	a. for loop i(0 -> matrix.length) and for loop j (0 -> matrix.length/2)
	b. Swap values by using temp and matrix[i][j] = matrix[i][matrix.length - 1 - j];

-------------------------------------------------------------------------------------------------------

Problem 2: - Merge overlapping subIntervals (returnType = int[][]):

1. Initialize List<int[]> res.
2. Check for negative scenario is null or of size 0 then return res.toArray(new int[0][])
3. Sort an array based on start interval: - Arrays.sort(intervals, Comparator.comparingInt(arr -> arr[0]));
4. Declare start and end as intervals[0][0] & intervals[0][1] respectively.
5. Iterate through each element and check if n[0] <= end then assign end = Math.max(end, n[1]) **to cover scenarios like [1,7] [3,6]**, ELSE
6. Add defined/new/previous pair into list: res.add(new int[]{start, end}); Also, re-assign start and end with current looping pair as n[0] & n[1]
7. Outside for loop, again add the pair(last pair during iteration).
8. return res.toArray(new int[0][]);

-------------------------------------------------------------------------------------------------------

Problem 4: - Find Duplicate number

1. Linked list cycle method: - Here, we are trying to create a linked list cycle (virtually)
2. Initialze slow & fast pointer as nums[0].
3. Then move slow pointer by 1 (slow = nums[slow]) and fast pointer by 2 (fast = nums[nums[fast]]), trying to find the collision point.
4. Once collided, mark fast pointer as nums[0] to zeroth index value.
5. Now start moving both the pointer by 1 place (slow = nums[slow]; fast = nums[fast]) and place where they will collide will be a duplicate number.

Intuition:
1. For first collision:- Since it is mentioned that duplicate is available, hence cycle is bound to be created and both pointer will collide.
2. For second collision on duplicate number: - For first collision, number of rounds fast pointer will take will be multiple of actual distance from starting point. So, when we move fast pointer at the start and begin moving both pointer by 1 then both will travel same distance.

-------------------------------------------------------------------------------------------------------

Problem 5: - Find missing & repeating number:

Naive approach is creating array of size n+1 and keep marking value as visited which we find in an array. At the end, repeated number count will be more than 1 & missing number count will be 0.

Optimized approach: -

1. Find summation (n * (n + 1 )/2) & summationSquare (n * (n + 1) * (2 * n + 1)) / 6
2. Iterate over array element and keep decrementing the value from summation & summationSquare as A[i] & A[i] * A[i] respectively.
3. Find sumNum using formula (summationSquare/summation)
4. Then, missingNumber will be (int) (summation + sumNum) / 2 & repeatedNumber will be (int) (missingNumber - summation).

Intuition: -
It will form mathematical equation as X - Y = S' and (X + Y) = P'/s' where X is missing number & Y is repeating number.

-------------------------------------------------------------------------------------------------------

*******************************************************************************************************

Day 3: Arrays Part - III

*******************************************************************************************************

Problem 1 (Leetcode): - Search in a 2D matrix for given condition: -
- Integers in each row are sorted from left to right.
- The first integer of each row is greater than the last integer of the previous row.

1. Find rowLength = matrix.length & colLength = matrix[0].length
2. Initialize low = 0 & high = (rowLength * colLength - 1)
3. Start looping till low <= high & calculate mid as (low + high) / 2
4. if matrix[mid / colLen][mid % colLen] == target then return true
5. if target > matrix[mid / colLen][mid % colLen] then low = mid + 1, ELSE
6. high = mid - 1;
7. Outside loop return false

Intuition: -
- If we convert matrix into array then as per above 2 condition array would be sorted. But we cannot use array as it will be counted as extra space. So, we are trying to create an imaginary index and trying to apply binary search algorithm.
- For finding matrix coordinate, we are using formula row = mid / colLen & column = mid % colLen.

-> Another flavour (GFG): Search in a 2D matrix for given condition: -
- row and column both are sorted

1. Initialze i = 0 & j = m - 1 (basically last column of first row)
2. Start looping till (i < n && j >= 0)
3. if (matrix[i][j] == target) retur true
4. if (target > matrix[i][j]) then i++; ELSE -> Moving downward
5. j-- -> Going leftward

Intuition: -
- We will start with last column of first row because from this coordinate all the value towards left will be smaller and towards down will be larger as per condition.
- If target is equal to coordinate value then return true.
- If target is greater than coordinate value then go down row wise ELSE move left (decrementing the column) -> As per intuition 1.

-------------------------------------------------------------------------------------------------------

Problem 2: - Pow(X, N):

**
 * Logic explanation: -
 * 2 ^ 10 = (2 * 2) ^ 5 = 4 ^ 5
 * 4 ^ 5 = 4 * 4 ^ 4 = 4 * 256 (from next step calculation ie ans)
 * 4 ^ 4 = (4 * 4) ^ 2 = 16 ^ 2
 * 16 ^ 2 = (16 * 16) ^ 1 = 256 ^ 1
 * 256 ^ 1 = 256 * 256^0 = 256 (Considered above)
 *
 * when n % 2 == 0 then x * x and reduce n by n/2
 * when n % 2 == 1 then ans * x and reduce n by n - 1
 *
 * for negative value: -
 * 2 ^ (-2) = 1 / (2 ^ 2) so calculate 2 ^ 2 and at last calculate 1/ans
 */

 1. Initialize ans = 1.0 & tempN = n
 2. if tempN < 0 then tempN = -1 * tempN
 3. Start looping till tempN > 0
 4. if tempN % 2 == 1 then ans = ans * x and reduce tempN by 1; ELSE
 5. x = x * x and reduce tempN by tempN / 2
 6. Outside loop check if n < 0 then ans = 1.0 / ans;
 7. Return ans

 ------------------------------------------------------------------------------------------------------

 Problem 3: - Majority Element:
 Condition: -
 The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 1. Initialize count & majorityElement as 0.
 2. Start looping each element (i) and check for 2 conditions.
 3. First if statement: if count == 0 then assign majorityElement as that element (i).
 4. Second if statement: if majorityElement == i then count += 1 ELSE count -= 1
 5. Return majorityElement.

 Intuition: -
 /**
 * Here, we have to find an element which occurs more than n/2 times.
 * First thing to click: - more than n/2 times means there will be only 1 element
 * Moore voting algorithm.
 * In problem statement it is mentioned that majority element will be more than n/2 times
 * It means its count will be greater than combined count of all elements.
 * So at the end, count of majority element will cancel out each other and still it wont be equal to 0.
 */


Other way: -

1. Define map and start looping over each element (i) and check for 2 conditions.
2. First if statement: if map contains key then insert key by incrementing value by 1 ELSE insert key with value as 1
3. Second if statement: if map.get(i) > n/2 then ans = i; //Because as per intuition their will be only 1 element which is greater than n/2 times

-------------------------------------------------------------------------------------------------------

Problem 4: - Majority Element - II:

/**
 * This time we have to find all element which occurs more than n/3 times.
 * First thing to click: - more than n/3 times means there will be only 2 elements or lesser than that
 * Boyer Moore voting algorithm.
 * Just like Moore voting algorithm, instead of 1 here we will track for 2 elements.
 */

 1. Initialize number1 = -1, number2 = -1, count1 = 0, count2 = 0
 2. Loop over elements and keep tracking number1, nummber2 & their counts using 4 if.. else if.. and increment while tracing. If none of conditions meet then decrement both the counter. -> This will ensure assigning 2 numbers which appears more times in sample input.
 3. Intialize result list and reassign count1 = count2 = 0.
 4. After getting 2 numbers occurred more times in input, start looping again & try finding respective counts using if else loop.
 5. Outside for loop, check if count1/count2 is greater than n/3 times using 2 if statements. If yes then add to the list and return.

-------------------------------------------------------------------------------------------------------

Problem 5: - Grid unique paths (Google interview question)

-> Naive approach (Using recursion): -

Intuition & steps: -
You will either move down (row + 1) or go right(col + 1). Keep traversing each path till you get either of 2 conditions and return following (base condition definition): -
    a. You reach to destination : if (i == m - 1 && j == n - 1) return 1 ELSE If
    b. Your row/column index goes beyond matrix size : if (i >= m || j >= n) so return 0.
return uniquePathsUsingRecursion(i + 1, j, m, n) + uniquePathsUsingRecursion(i, j + 1, m, n);

-> Better solution (Using DP): -

Same as above but with some optimization. Here, we will store the result of each recursion path and check while recursion if we have some non-default value for this iteration.
We will define arr as: int[][] arr = new int[m][n] and pass it as reference everytime.
You will either move down (row + 1) or go right(col + 1). Keep traversing each path till you get either of 2 conditions and return following (base condition definition): -
    a. You reach to destination : if (i == m - 1 && j == n - 1) return 1 ELSE If
    b. Your row/column index goes beyond matrix size : if (i >= m || j >= n) so return 0 ELSe If
    c. Check if we have iterated this path before: if (arr[i][j] != 0) then return arr[i][j];

return arr[i][j] = uniquePathsUsingRecursion(i + 1, j, m, n) + uniquePathsUsingRecursion(i, j + 1, m, n);

-> Optimized approach (Using combinations): -

Intuition:
/**
 * Google interview question : Combination problem
 * for 2 * 3 matrix:-> m = 2, n = 3
 * Observation 1: Possible combination: R-R-D, D-R-R, R-D-R : It means 3 steps are required to reach an end point
 * Observation 2: 2 right direction means col - 1 and 1 downward direction mean row - 1 => col + row - 2
 * Conclusion: - Out of total steps (m + n - 2) of C to the base either (m - 1) OR (m + n - 2)C(n - 1)
 */


1. For combination problem (N C R), we will calculate N as m + n - 2 and R will either m - 1 or n - 1
2. Initialize res = 1.0.
3. Loop (1 to <= R), and apply formula: res = res * (N - R + i) / i;
4. return (int) res;

-------------------------------------------------------------------------------------------------------

Problem 6: - Reverse Pairs. (Not implemented yet)

-------------------------------------------------------------------------------------------------------

*******************************************************************************************************

Day 4: Arrays Part - IV

*******************************************************************************************************

Problem 1: - Two Sum:

1. Initialize Map<Integer, Integer> and diff = 0.
2. Start looping over each element (0 -> nums.length) and find diff as target - nums[i];
3. check if (map.containsKey(diff)) then return new int[]{map.get(diff), i}; ELSE map.put(nums[i], i);
4. Outside loop return new int[]{-1, -1};

-------------------------------------------------------------------------------------------------------

Problem 2: - Four Sum:

1. Check negative scenario, initialize List<List<Integer>> res = new ArrayList<>() and then sort the arrays.
2. 2 for loops : i (0 -> n) and j (i + 1 to n) and calculate the diff as target - nums[j] - nums[i];
3. Initialize low = j + 1 & high = n - 1 and apply binary search
4. while low < high check if (diff < nums[low] + nums[high]) then high--; ELSE IF (diff > nums[low] + nums[high]) then low++; ELSE
4. Create a list and add all four numbers i, j, low & high in sequence since we want all distinct quadrets. Then add this list to res list.
5. Within same while loop, skip duplicate numbers for pointer low & high to search for next combination: -
    a. while(low < high && nums[low] == list.get(2)) low++;
    b. while(low < high && nums[high] == list.get(3)) high--;
    NOTE: list.get(2)) & list.get(3)) is used because we have added low & high at 2nd & 3rd indexes of list. Refer step 4.
6. Outside while loop and within loop scope of j, skip duplicate numbers for j as well
    a. while (j + 1 < n && nums[j] == nums[j + 1]) ++j;
    Here, j will still be pointing to duplicate number, but ++j in for loop will move pointer to next non-duplicate number.
7. Outside for loop j & within loop scope of i, skip duplicate numbers for i as well
    a. while (i + 1 < n && nums[i] == nums[i + 1]) ++i;
    Here, i will still be pointing to duplicate number, but ++i in for loop will move pointer to next non-duplicate number.

-------------------------------------------------------------------------------------------------------

Problem 3: - Longest Consecutive sequence:

Intuition: -
Here, we are trying to find the  minimal value of the sequence so that we can start checking from that number upto complete sequence available.

1. Create hashset and add all values into Hashset.
2. Initialize longestStreak, currentNum, currentStreak = 0.
3. Loop again over all elements and check if **(!hashSet.contains(n - 1))** to get the minimal value of that sequence.
4. Once we get the minimal value then define currentNum as that number n and currentStreak = 1 within same if statement;
5. Then start looping while(hashSet.contains(currentNum + 1)) and increment currentNum & currentStreak by 1.
6. Outside if loop & within for loop, assign longestStreak = Math.max(longestStreak, currentStreak);
7. return longestStreak;

-------------------------------------------------------------------------------------------------------

Problem 4: - Largest subarray with zero sum

/**
 * Intuition: Let say we have an array of size 10 and summation required is 15.
 * If by 4th index we got our summation = 15, it means from 5th to 9th index summation will be zero.
 * Same logic we are going to apply here. It will be divided into 2 halves.
 * 1. From start, keep adding values and check if sum == 0, otherwise keep storing sum and index into map.
 * If we get sum == 0 from the beginning then calculate maxi by i + 1. That will be your first sequence.
 * 2. Then after every sum, check if it exists in map.
 * If yes, it means that we received that sum earlier at particular index.
 * This indicates that after that index till current index, summation is zero as per our intuition above.
 * So, calculate the sequence length by current index - index of that sum and compare it with maxi.
 * Don't store this sum and index pair in map, bcoz key already exist and also we want largest sequence.
 * Otherwise, index will get updated to recent one and we wont be able to get largest sequence.
 */

 1. Check negative scenario if length is 0 then return 0.
 2. Initialize map and sum = 0, maxi = 0;
 3. Start looping over element and keep adding it into sum as sum += arr[i]; and execute above mentioned steps
    a. if sum == 0 then maxi = i + 1; ELSE
    b. else if map.containsKey(sum) then maxi = Math.max(maxi, i - map.get(sum)); ELSE
    c. else map.put(sum, i); //Storing sum & index
 4. Outside loop, return maxi;


-------------------------------------------------------------------------------------------------------

Problem 5: - Count number of subarrays with given Xor K:

Intuition: -
If prefix XOR is XR and we have some patches which gives XOR as K and remaining XOR as Y then we can say thay Y ^ K = XR.
This can be reduced as as Y = XR ^ K. Here, we have to find the frequency of such Y's that will ultimately leads to count of such subarrays which will give XOR as K.

Steps (B is target XOR):
1. Initialize map & count = 0, xor = 0.
2. Iterate over each element j and find prefix xor = xor ^ j    //Equation explained above
3. Check if (xor == B) then increment count by 1.
4. Check if (map.containsKey(xor ^ B)) then count += map.get(xor ^ B)
5. Check if (map.containsKey(xor)) then map.put(xor, map.get(xor) + 1); ELSE
6. map.put(xor, 1);
7. Outside loop, return count.

-------------------------------------------------------------------------------------------------------

Problem 6: - Longest substring without repeat:

Intution/Steps:

**
 * Keep adding character in a map with its index value till we get non-repeating character
 * by incrementing right pointer & calculate maxLength.
 * If we get any repeated character, move left pointer to right + 1 to skip all iterations in between.
 * Also, repeated character should be within range of considered sequence.
 * For eg: - tmmxuzt - last char 't' is out of range when 't' first occurred at index 0
 * for the longest sequence mxuzt. For this longest sequence, left will be at index 2 & right will be at 6.
 * However, first 't' found at index 0 which is out of range of 2 & 6.
 * If its not within sequence range then keep it as it is.
 * Handled by: - -> Math.max(map.get(s.charAt(right)) + 1, left) -> Math.max(1, 2) -> 2 as per above eg.
 * And update the index of repeated character index as per last occurrence.
 */

1. Initialize map & left = 0, right = 0, maxLength = 0;
2. Start looping till (right < s.length()) check if character is available in map using condition (map.containsKey(s.charAt(right))). If available then assign left as left = Math.max(map.get(s.charAt(right)) + 1, left);
    This will also handle if character index is available within evaluating range.
3. Outside if statement but within while loop assign maxLength as Math.max(maxLength, right - left + 1);
    //This is used to evaluate maximum length.
4. Keep adding character in map and incrementing right pointer using map.put(s.charAt(right), right++);

-------------------------------------------------------------------------------------------------------

*******************************************************************************************************

Day 5: LinkedList

*******************************************************************************************************

Problem 1: - Reverse a Linked List

Steps: -
1. Check for negative scenario if head is null then return null.
2. Initialize dummy node newHead as null.
3. Start looping till head != null.
    a. Assign pointer to next node: ListNode next = head.next;
    b. Reverse a direction (first iteration to null & then next instance to previous node): head.next = newHead;
    c. Move dummy node to current/head node (To maintain the previous node address for next iteration): newHead = head;
    d. Move head node to next node: head = next;
4. return newHead;

-------------------------------------------------------------------------------------------------------

Problem 2: Find middle of LinkedList:

1. Initialize fast and slow pointer as ListNode fast = head, slow = head;
2. Start looping until fast != null && fast.next != null
3. Move slow and fast pointer as
    a. slow = slow.next;
    b. fast = fast.next.next;
4. return slow;

-------------------------------------------------------------------------------------------------------

Problem 3: : Merge two sorted Linked List:

1. If list1 is null then return list2. If list2 is null then return list1.
2. Make sure that list having smaller value should be marked as list1 (always with different conditions) by using condition if (list1.val >= list2.val) and then swap.
3. Assign ListNode res = list1;
4. Start looping till list1 != null && list2 != null and always initialize temp as null. (This temp node will be used to remind last node of previous iteration).
5. Till list1 has lesser value than list2, assign current node to temp1 & keep incrementing list1 to next value.
    Again start while loop till list1 != null && list1.val <= list2.val
    Assign temp as list1 & list1 as list1.next;
6. Outside inner while loop(will break if l2.val > current l1.val OR list 1 as null. It means next value will be l2.val, hence assigning to temp.next), assign temp.next to list2.
7. Swap: to ensure next smaller value of list will marked as list1
8. Return res

-------------------------------------------------------------------------------------------------------

Problem 4: : Remove nth node from the end of LinkedList

Use fast slow pointer to solve this problem. Here slow pointer will be one node behind at the end of traversal. So, break the link using step 5.

1. Create a dummy node (startNode) which will hold the address of head (//useful in edge cases like if we have to delete the nth node from back ie first node from start. slow will be at dummy node and by slow.next = slow.next.next; -> will give head next).
2. Create slow and fast pointers pointing at startNode.
3. Start loop from **(1 to <= n)** and move fast pointer by 1 as fast = fast.next;
4. Start looping till fast.next != null and move both the pointers by 1.
5. By the time fast will move to null, slow pointer will be at point where next nodes need to be deleted. So, break this link using slow.next = slow.next.next;
6. return startNode.next;

-------------------------------------------------------------------------------------------------------

Problem 5: : Add 2 numbers as LinkedList

1. Create a dummy node to store head address & temp node (point to dummy node) which will keep moving ahead to new added node.
2. Initizlize sum as 0
3. Start looping until both list pointer not reaches to null or carry greater than 0 (l1 != null || l2 != null || carry == 1)
4. Use 2 if statement and get the sum of both list pointer values if non-null and move to next node
    a. if (l1 != null) then sum += l1.val; l1 = l1.next;
    b. if (l2 != null) then sum += l2.val; l2 = l2.next;
5. Then, add carry into sum variable.
6. Calculate carry performing div operation on sum.
7. Create newNode by performing mod operation on sum and enter its address to temp.next as temp.next = newNode;
8. Move temp pointer to newly added node as temp = temp.next
9. Outside loop, return dummy.next;


-------------------------------------------------------------------------------------------------------

Problem 6: Delete a given node when node is given:

1. Copy next node value into current node val: node.val = node.next.val;
2. Copy next to next node address into current node next: node.next = node.next.next;

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 6: LinkedList - Part-II

*******************************************************************************************************

Problem 1: Intersection point of 2 LinkedList

Intution for optimal approach:
If we move both the pointers together for 2 iteration (in first iteration if any of node reaches to null then swap the head and restart moving the pointers together), then in case of existing intersection they will collide to common node in second iteration. Otherwise they will move to null at the same point.

Steps:
1. Create pointer a & b pointing to headA & headB respectively.
2. Start looping until a != b and check if any of pointer reachs to null then assign to other list head and keep incrementing again otherwise simply move to next node.
    i.  a = a == null ? headB : a.next;
    ii. b = b == null ? headA : b.next;
    Note: Here, For the end of first iteration, we are just resetting the pointer to the head of another linkedList
3. Outside loop, return a.

-------------------------------------------------------------------------------------------------------

Problem 2: - Detect a cycle in LinkedList:

Use low and fast pointer. If there will be loop then they will collide at one point otherwise fast pointer will reach to null

1. Declare slow & fast pointer pointing to head.
2. Start looping till (fast != null && fast.next != null)
3. Move slow by 1 & fast by 2 pointers.
4. Check if (fast == slow) then return true. Otherwise continue with next iteration.
5. Outside loop, return false. Because if loop exist it will be handled and return true within loop itself.

-------------------------------------------------------------------------------------------------------

Problem 3: - Reverse a LinkedList in groups of size k:


-------------------------------------------------------------------------------------------------------

Problem 4: - Check if a LinkedList is palindrome or not:

1. Check negative scenario: if (head.next == null || head == null) return true;
2. Declare slow & fast pointer pointing to head.
3. We will try to find middle of linkedList. Hence, start looping till (fast.next != null && fast.next.next != null) and move slow by 1 & fast by 2 pointers.
4. Now reverse the list and store the head of reversed list to slow pointer. (for logic refer, Day 5 problem 1 above) Basically reverse the right half.
5. Move slow to next pointer which will be head of reversed list. In hindsight, move slow to right half.
6. Start looping till (slow != null). Checking for left & right half value.
7. Check if head.val != slow.val then return false.
8. Move head and slow to next pointer.
9. Outside loop return true. Because is it will not be palindrome then will return false from step 7 only.

-------------------------------------------------------------------------------------------------------

Problem 5: - Find the starting point of the Loop of LinkedList:

Intuition: Similar to Find duplicate problem (Day 2 Problem 4)

1. Create fast and slow pointer pointing to head.
2. Start looping till (fast != null && fast.next != null) and increment slow by 1 & fast by 2 pointers.
3. Check if (slow == fast) if yes then
    a. Move fast pointer back to head.
    b. Start looping till fast != slow and move both pointers by 1. Both pointers will come at same position where loop will begin.
    c. return fast.
4. Keep going with next iteration of step 2.
5. Outside loop, return null. If linkedlist contains loop then it will be returned by 3.c

-------------------------------------------------------------------------------------------------------

Problem 6: Flattening of a LinkedList:


-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 7: LinkedList & Arrays:

*******************************************************************************************************

Problem 1: Rotate a LinkedList

Intuition: - Pointing last node to first node as after rotating last node will point to first

1. Declare a node curr pointing to head & compute length of a LinkedList. In the same process reach to last node.
2. After that implement the intuiton using curr.next = head;
3. Compute k by performin mod operation to handle edge cases where k > n : k = k % length
    Note: - k's multiple will have original list after rotations. If length is 5, so after 5, 10, 15th... rotation, it will be similar to original list.
4. Traverse till that node ie. if len is 5 and rotation needed is 2, so we traverse till 3rd node.
    a. k = length - k
    b. while (k-- > 0) curr = curr.next;
5. Make the node head and break the connection.
    a. head = curr.next;
    b. curr.next =null;
6. return head

-------------------------------------------------------------------------------------------------------

Problem 2: Clone a Linked List with random and next pointer

Declare iter(keep iterating to next node & point to head again before starting step 2 & 3) & front (use it for storing next node address) pointing to head.
1. Make copy of each node and link them together side-by-side in a single list.
2. Assign random pointers for the copy nodes : **iter.next.random = iter.random.next**;
3. Restore the original list, and extract the copy list.

-------------------------------------------------------------------------------------------------------

Problem 3: 3 Sum
Condition: i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Intuition: - a + b + c = 0. Hence, a = - (b + c). So, we will keep 'a' constant and try to find out b + c

1. Check for -ve scenario: if length < 3 return empty list.
2. Sort an array to get duplicates together & initialize List<List<Integer>> res
3. Start loop i (0 -> < length - 2)
4. Major if condition: (i == 0 || (i > 0 && nums[i] != nums[i - 1])) // to avoid duplicates for 'a'
    a. Declare low = 0 & high = length - 1 & **sum = -nums[i]**
    b. Start looping till low < high
    c. if (nums[low] + nums[high] == sum) then add it into res as Arrays.List in sequence of i, low & high to get unique triplets.
        i. Within same while loop, start loop again to skip duplicate number for low:
        while (low < high && nums[low] == nums[low + 1]) low++;
        ii. Within same while loop, start loop again to skip duplicate number for high:
        while (low < high && nums[high] == nums[high - 1]) high--;
        iii. Then increment both low & high by 1.
    d. ELSE if (nums[low] + nums[high] < sum) low++;
    e. ELSE high--
5. return res.

-------------------------------------------------------------------------------------------------------

Problem 4: Trapping rainwater:



-------------------------------------------------------------------------------------------------------

Problem 5: Remove Duplicate from Sorted array:
Condition: -
Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]

1. Check -ve scenario. If length == 0 the return 0.
2. Declare i = 0. (It will ensure the index at which unique element will be present)
3. Start loop j (1 to < len).
4. Check if (nums[i] != nums[j]) then **nums[++i] = nums[j];**
5. Outside for loop, return i + 1; (i is index here, we have to return number of elements after removing duplicates)

-------------------------------------------------------------------------------------------------------

Problem 6: Max consecutive ones

1. Check -ve scenario. If length == 0 the return 0.
2. Declare maxi and count as 0.
3. Start loop i (0 -> n)
4. Check if (nums[i] == 1) then count++; ELSE
5. assign maxi as Math.max(count, maxi); Also set count to 0;
6. Outside for loop, return **Math.max(count, maxi);**

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 8: Greedy Algorithm:

*******************************************************************************************************

Problem 1: N meetings in one room

1. Try to convert given input in the form of object. So, create Meeting class, create an object with index as pos & add it into the list.
2. Sort the objects based on end time so that meeting with minimum finishing time will be at top. **If end time is equal then sort based on pos.**
3. After sorting, since mininum finishing time is at top, declare count as 1 & endLimit as meetings.get(0).end;
4. Start loop i (1 -> < n) and check if (meetings.get(i).start > endLimit).
5. If yes, then count++; assign new endLimit as meetings.get(i).end.
6. Outside for loop, return count.

-------------------------------------------------------------------------------------------------------

Problem 2. Minimum number of platforms required for a railway

Intuition: -
1. Sorting both will change the indexes of train timings but at the end arrival & departure time matters.
2. If train is arriving, it will occupy the platform & while leaving, it will leave the platform vacant.
3. So, we are just gonna play with train timings of an entire day.

Steps: -
1. Sort both the arrays.
2. Initialize *i = 1*(pointing to arrival array) & j = 0 (pointing to departure array). Also, plat_needed = 1, result = 1;
3. Start looping till (i < n && j < n) and check for 3 conditions
4. check if arrival time is lesser than departure time then additional platform would be needed. Also increment i.
    if (arr[i] <= dep[j]) then plat_needed++; Also, i++;
5. check if arrival time is greater than departure time then additional platform won't be needed. Also increment j.
    else if (arr[i] > dep[j]) then plat_needed--; Also, j++;
6. Check for maximum no. of platform value.
    if (plat_needed > result) then result = plat_needed OR result = Math.max(result, plat_needed);
7. Outside loop, return result;

-------------------------------------------------------------------------------------------------------

Problem 3: Job sequencing problem:

Intution:
We are going to sort the objects in descending order of their profit. Then, will perform each job on last day of their respective jobs. If that slot is occupied then move towards zero to find any empty slots. If found then perform job otherwise move ahead with next iteration.

Steps:

1. Sort an objects in descending order of their profit : Arrays.sort(arr, (a, b) -> b.profit - a.profit);
2. Start looping & find maximum deadline from the objects using maxi variable.
3. Outside loop initialize an array result of max_deadline(from step 2) + 1.
4. Start looping i (*1* to <= max_deadline) and initalize all indexes with -1.
5. Outside loop, initialize count & maxProfit as 0.
6. Now, 2 for loops : 1st to iterate over all job ids & 2nd to iterate from given deadline towards 0 to find the empty slot.
7. Start loop i (0 to < n) & j (arr[i].deadline to > 0)
8. Check if (result[j] == -1) then      //Slot found
    a. result[j] = i;
    b. count++;
    c. maxProfit += arr[i].profit;
9. Outside both loops, return new int[]{count, maxProfit};

-------------------------------------------------------------------------------------------------------

Problem 4: Fractional Knapsack Problem

Intuition:
Sort the object in decreasing order of value/weight. Also, take care of datatype. Convert it to double while performing div operation.

Steps: -
1. Sort the array in decreasing order of value/weight.
2. Declare currentWeight as 0 & result = 0.0
3. Start loop i and perform if else operation
    a. Check if (currentWeight + arr[i].weight <= W) then assign currentWeight += arr[i].weight & result += arr[i].value;
    b. ELSE calculate the remanining as W - currentWeight.
        Multiply it with value/weight calculation: result += ((double) arr[i].value / (double) arr[i].weight) * (double) remain;
        ***break;***    //Because this will fill the capacity so no need to iterate over further elements.
4. return result;

-------------------------------------------------------------------------------------------------------

Problem 5: Find minimum number of coins:
Conditions: we have denominations in abundance. Means any coin can be used any number of times.

Intuition: Find minimum/equal denotions that is closer to V.

Steps:
1. Declare Indian denominations & minimumCoins as 0
2. Start looping i (length - 1 till >=0 && V > 0)
3. Loop again till (V >= deno[i]) // When V values go lesser than current denomination, then move to lesser denomination
    a. V -= deno[i];
    b. minimumCoins++;
return minimumCoins;

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 9: Recursion:

*******************************************************************************************************

Problem 1: - Subset Sums:

Intuition: For each index, we will perform pick/not pick technique until we reach at last index. So, base condition is last index == n.

Steps: -

1. Create an arrayList for storing the result and pass it as a reference to the function which will be used as recursive function along with index & sum as 0.
2. Base condition: - if (index == arr.size()) then add sum to the list and return.
3. Apply pick & non-pick technique: -
    a. pick : - findSubsetSum(index + 1, sum + arr.get(index), arr, subsetSums);
    b. not pick: - findSubsetSum(index + 1, sum, arr, subsetSums);

-------------------------------------------------------------------------------------------------------

Problem 2: - Subsets - II

Steps: -

1. Create a List<List<Integer>> ans for storing the result & pass as a reference. Also, pass empty list ds for each subset along with index = 0. Also, sort the array.
2. Add list to the ans. (every recursive call will have subset that needs to be stored. Also, empty list during first call)
3. Loop i will run from **index -> length**
    a. check for duplicates: - if (i != index && arr[i] == arr[i - 1]) then continue; (no need to add. Move to next iteration)
    b. Add array element i into the ds.
    c. Call recursive function for i + 1 index: findSubsets(i + 1, arr, ans, ds);
    d. Remove last element after coming back from recursion : ds.remove(ds.size() - 1);

-------------------------------------------------------------------------------------------------------

Problem 3: Combination sum - I

1. Create a List<List<Integer>> ans for storing the result & pass as a reference. Also, pass empty list ds for each subset along with index = 0.
2. Base condition: - 2 if conditions : if (index == arr.length) ->  if (target == 0) then add to the ans list -> then return
3. Apply pick & non-pick technique: -
    a. pick after checking if (target >= arr[index])
        i. ds.add(arr[index]);  //Remain at same index as it is asked in question that you can take value for any no. of times as part of combination
        ii. findCombinations(index, arr, target - arr[index], ans, ds);     //Also, decrement the target with index.
        iii. ds.remove(ds.size() - 1);
    b. not pick: findCombinations(index + 1, arr, target, ans, ds);

-------------------------------------------------------------------------------------------------------

Problem 4: Combination sum - II

1. Create a List<List<Integer>> ans for storing the result & pass as a reference. Also, pass empty list ds for each subset along with index = 0. Also, sort the array.
2. Base condition: - if (target == 0) then add to the ans list, then return
3. Loop i will run from **index -> length**
    a. check for duplicates: - if (i != index && arr[i] == arr[i - 1]) then continue; (no need to add. Move to next iteration)
    b. if (arr[i] > target) then break;     //If after reducing the target, next value is greater than all numbers after that will be greater as array is sorted. So, break the loop for this recursion
    c. Add array element i into the ds.
    d. Call recursive function for i + 1 index & reducing the target: findCombinations2(i + 1, arr, target - arr[i], ans, ds);
    e. Remove last element after coming back from recursion : ds.remove(ds.size() - 1);

-------------------------------------------------------------------------------------------------------

Problem 5: Palindrome Partitioning

1. Create a List<List<String>> ans for storing the result & pass as a reference. Also, pass List<String> ds for each subset along with index = 0.
2. Base condition: - if (index == s.length()) then add to the ans list, then return
3. Loop i will run from **index -> length**
    a. check if string is palindrome: if (checkPalindrome(s, index, i))
        i. Add path from index till i + 1 :- ds.add(s.substring(index, i + 1));
        ii. Call recursive function for i + 1 index : performPartition(i + 1, s, res, ds);
        iii. Remove last element after coming back from recursion : ds.remove(ds.size() - 1);

-------------------------------------------------------------------------------------------------------

Problem 6: K-th permutation Sequence : for n given number, find kth permutation sequence

Intuition: - div operation will give the number for each index in kth sequence, mod operation will give which sequence to look for from remaining set of numbers

1. Calculate factorial for n - 1 and simultaneously add number into list.
2. For 0-based indexing, do k = k - 1 and declare String ans = "" to store the result.
3. Start infinite loop.
    a. ans = ans + numbers.get(k / fact); //This will give the number for each index in kth sequence.
    b. Remove that number from list and then check if list is empty then break the infinite loop.
    c. Perform mod operation k = k % fact; //This will give the sequence to look for after removing the element from step 3.b
    d. Calculate its factorial which should be fact / number of remaining elements. : fact = fact / numbers.size();
4. return ans;

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 10: Recursion & Backtracking:

*******************************************************************************************************

Problem 1: - Print all permutations of a string/array

Intuition: Try out each number at each position by swap from current index to i.

Steps: -

1. Create a List<List<Integer>> ans for storing the result & pass it as a reference.
2. Base condition: - if (index == nums.length) then create list and add all elements in it. Add this list into ans and return.
3. Loop from current index to n - 1.
    a. Swap the number from current index to i: swap(nums, index, i);
    b. Call function recursively by index + 1: findPermute(index + 1, nums, ans);
    c. Swap the number from current index to i: swap(nums, index, i);   //After completing the recursion, restore the array values.

-------------------------------------------------------------------------------------------------------

Problem 2: - N queens Problem

Intuition: -
1. We will hold 1 column at a time and traverse for each row if we can place a queen or not. So, we will call function recursively for every column. Within each recursive call, traverse for each row (0 to n).
2. As we know Queen can attack in 8 directions. But here we will be moving from left to right so, it will cancel out 4 rightward directions attack + 1 column level attack (since we will place only 1 Queen in 1 column as per conditions).
3. We have to take care for 3 types of attack since 5 are cancelled out: -
    a. Check for left diagonal: - row
    b. Check for lower diagonal: - row + column
    c. Check for upper diagonal: - (n - 1) + (column - row)

Steps: -

1. Create a chess board of n * n matrix and initialize each coordinates by '.'
2. Create 3 arrays for hashing/indexing which will take care of whether queen is safe to be placed or not
    a. int[] leftRow = new int[n];
    b. int[] lowerDiagonal = new int[2 * n - 1];
    c. int[] upperDiagonal = new int[2 * n - 1];
3. Create List<List<String>> res to store result and pass it as a reference. Call recursive function with col 0.
4. Base condition: - if (col == board.length) then construct the answer. (Look at the code)
5. Traverse row wise from 0 to n and check for condition if (leftRow[row] == 0 && lowerDiagonal[row + col] == 0 &&
    upperDiagonal[(board.length - 1) + (col - row)] == 0)   //Whether queen is safe or not
    a. Based on this, place the queen and mark indexes as 1.
    b. Go for next col as col + 1.
    c. after coming back from recursion, unplace the queen and mark the indexes as 0.

-------------------------------------------------------------------------------------------------------

Problem 3: - Sudoku Solver:

Intuition: -
1. Traverse for each row,column to find out empty place.
2. Then try out char 1 to 9 which can be filled for this empty space.
    a. Check by keeping row constant and moving i
    b. Check by moving i and keeping column constant
    c. Check for 3 * 3 matrix using formula: if **(board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)**
3. After filling that vacant space, call function recursively to check if all the empty spaces within that recursion tree get filled or not. If yes then return true ELSE after that recursion remove that char from that place to make it vacant.
4. If none of the char from 1 t0 9 can be filled then too return false.
5. Outside all for loop code will come when it will check all the places and now none of the position is empty. It means sudoku is solved. So return true.

(Look code for reference)

-------------------------------------------------------------------------------------------------------

Problem 4: - M coloring Problem:

Intuition: -



-------------------------------------------------------------------------------------------------------

Problem 5: - Rat in a Maze

Intuition: - We will move into DLRU directions as this lexicographical to get ans in sorted form. Also use di & dj for avoiding 4 direction traversal using if statement. Also, we cannot visit one node twice so using indexing to keep a trace of visited paths. Also, checks for next movement if its equal to 1. Because if its 0, we cannot move to next co-ordinate.


1. Create vis array of same m * n matrix size.
2. Initialize di & dj as (This is created to avoid 4 if statement for 4 different directions. It indicates how much increment needed for i & j to move as DLRU):
    int[] di = {1, 0, 0, -1};
    int[] dj = {0, -1, 1, 0};
3. Call the function if (m[0][0] == 1)
4. Base conditition: - if (i == n - 1 && j == n - 1) then add into res list and return.
5. Define String dir = "DLRU"; and start loop index from 0 to 4 which will iterate for 4 directions defined.
6. Calculate nexti & nextj as
    int nexti = i + di[ind];
    int nextj = j + dj[ind];
7. check for boundary conditions && visited && next value as 1 then:
    a. Mark current coordinate as visited
    b. Call recursive function with string added from dir at **index**
    c. Mark current coordinate as unvisited after coming from recursion.

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 11: Binary Search:

*******************************************************************************************************

Problem 1: The N-th root of an integer

1. Take low and high. Low will be equal to 1 and high will be M. We will take the mid of low and high such that the searching space is reduced using low + high / 2.0
2. Run the while loop till (high – low > eps). Take eps as 1e-6, since we have to find answers to 6 decimal places.
3. If multiplying mid N times is greater than M, then we will reduce high such that high = mid. Else, if it is lesser than M then we will increase low such that low = mid.
4. After the loop breaks we will have our answer as low or high.

-------------------------------------------------------------------------------------------------------

Problem 2: Find the element that appears once in a sorted array, and the rest element appears twice (Binary search)

Intuition: -
Left half before element appears once: -
1st occurrence: even index
2nd occurrence: odd index

Right half after element appears once: -
1st occurrence: odd index
2nd occurrence: even index

Goal is to find the breaking point. Once low crosses high, that arr[low] will be the element that appears once.
During every search, we would have to check if it lies in left half or not. If yes, then move low to mid + 1 to find breaking point and if no then move high to mid - 1 to find the left half.

Steps: -

1. Take low as 0 and high as **nums.length - 2** //To handle scenario where element appears once is at last index.
    If we will keep high at last index in that case all element before it will be sorted and considered as left half. Hence, high pointer will never move and at last low will reach high but it will never cross high. Therefore, we are keeping it at second last index.
2. Start while loop till low <= high
    a. Calcluate mid as (high + low) / 2.
    b. Check if (nums[mid] == nums[mid ^ 1]) then low = mid + 1;    //If left half then find the break point.
    c. ELSE high = mid - 1.     //If right half, shrink high pointer to find left half.
3. return nums[low]

Note: - mid ^ 1 :
    a. If mid is odd index then it will give previous even index.
    For eg: for index 3 (mid) -> 1 1 ^ 1 = 1 0 = 2
    b. If mid is even index then it will give next odd index.
    For eg: for index 4 (mid) -> 1 0 0 ^ 1 = 1 0 1= 5

-------------------------------------------------------------------------------------------------------

Problem 3 : Search in rotated sorted array

Intuition: -

Apply binary search with additional checkpoint if left array is sorted or right array sorted and try to figure out if target is available in that half or not.

-------------------------------------------------------------------------------------------------------

Problem 4 : Median of 2 sorted array

Intuition: -
1. To get left1, left2, right1 & right2 for comparison. Because for finding median we need 2 element in case of even length or 1 element in case of odd length.

Now, idea is if we combine both array so, it should be sorted one. If we are dividing it from any index, left half values will be smaller than right half.
So just ensuring by below condition, if we are cutting the arrays properly or not.
Hence, doing cross array element check because since array is sorted then comparing left1 with right1 & left2 with right 2 will always be true.
2. Apply condition: if (left1 <= right2 && left2 <= right1) then
    a. for even length -> return max(l1, l2) + min(r1, r2) / 2.0
    b. for odd length -> return max(l1, l2)

3. ELSE If (left1 > right2) then high = cut1 - 1 //if left1 from 1st array is greater than right1 of second array
    then, Left1 ko kam karna padega toh high ko kam karo.

4. ELSe low = cut1 + 1;
if left2 from 1st array is greater than right2 of second array then left2 ko chota krna padega, jiske liye left1 ko badhana padega. toh low ko aage lekar jaao.
left1 ko badhaaenge tab hi left2 me kam values aaenge. Since array is sorted toh kam value, matlab moving towards lower side.

Steps: -
1. **Check size of both the arrays and make sure nums1 is the lower size array.** Otherwise corner cases fail hoga. Also, it will reduce the binary search space.
2. Take low as 0 and high as n1 (nums1.length)
3. Start looping till (low <= high)
4. Find out cut1 as breaking point for array1 & cut2 as breaking point for array2
    a. int cut1 = (low + high) / 2;
    b. int cut2 = ((n1 + n2 + 1) / 2) - cut1;
5. Handle Edge cases:
    a. If cut1 is 0 means cut1 - 1 would be outside boundary. It means not picking any element from array. So, assign it as min value for comparison.
    int left1 = cut1 == 0 ? Integer.MIN_VALUE : nums1[cut1 - 1];
    int left2 = cut2 == 0 ? Integer.MIN_VALUE : nums2[cut2 - 1];

    b. If cut2 is n means cut1 would be outside boundary. It means not picking any element from array. So, assign it as max value for comparison.
    int right1 = cut1 == n1 ? Integer.MAX_VALUE : nums1[cut1];
    int right2 = cut2 == n2 ? Integer.MAX_VALUE : nums2[cut2];
6. Check for condition explained in intuition above.
7. Outside loop, return 0.0;

-------------------------------------------------------------------------------------------------------

Problem 5: K-th element of two sorted arrays

Inutition:
1. It is exactly similar 2 previous problems. Except, in previous problem we were trying to have exactly half element on left hand side after proper cut. Here, we are trying to have k element on left hand side after proper cut.
int cut1 = (low + high) / 2;
int cut2 = k - cut1;

2. Since we are making sure to have k element on left half, we can return maximum of l1,l2
return Math.max(left1, left2);

3. Very important thing to make sure we assign valid low & high pointer based on k value. To handle edge cases like if k < arr1.size or k > arr2.size because from above condition we ensure that arr1 will be lesser size & arr2. is of greater size.
Consider eg after swapping: arr1 = {1, 4, 6, 8} & arr2 = {2, 3, 5, 7, 9}
    a. Condition 1 : k = 3 which is < arr1.length
    Here, we cannot have low as 0 and high as 4 because k = 3, So we cannot pick 4 values from arr1 after partitioning. Hence, high will be 3 here which is k.
    So, it means high can be *min*(k, arr1.length)

    b. Condition 2 : k = 6 which is > arr2.length
    Here, we cannot have low as 0 because if low is zero then for 1 of the scenario it will partition where it wont pick any value from arr1 & all values from arr2 (which is not possible because arr2 ka size is 5 and we want 6 elements.. right??). Iska matlab atleast 1 element to pick karna hi padega arr1 se. So, low cannot be 0.
    So, low needs to be start with 1 which is k - arr2.length. Therefore, low = *Math.max*(0,k - m)

-------------------------------------------------------------------------------------------------------

Problem 6: Allocate Minimum Number of Pages

Intuition: -
1. Apply binary search keeping low as first number of an array & high as sum of all elements of an array.
2. Calculate mid and consider it as a barrier to find out how many pages can be allocated to each student within that barrier.
3. If its a valid barrier means within barrier all condition would met and pages allocated to each student provided then keep decrementing the high pointer to find the minimal one.
4. If its not a valid barrier then increment low to mid + 1.

Steps: -

1. Check for negative scenario, if array length is less than no. of students return -1. Because condition is : Each student has to be allocated at least one book.
2. Define low as first number of an array & high as sum of all array elements.
3. Start looping while (low <= high)
    a. calculate mid.
    b. Check if isValidAllocation then store the mid into res and high = mid - 1.
    c. ELSE low = mid + 1;
4. isValidAllocation function: -
    a. Initialize noOfStudents = 0 & pagesAllocated = 0;
    b. start looping i 0 to n
    c. if (pagesAllocated + A[i] > barrier) then increment noOfStudents by 1 & pagesAllocated = A[i].
        i. **After allocating new pages to next student please ensure that is should be within barrier range. if (pagesAllocated > barrier) return false;**
    d. ELSE Keep adding the pages as pagesAllocated += A[i];
    e. After for loop check, if noOfStudents > B then return false;
    f. return true;

-------------------------------------------------------------------------------------------------------

Problem 7: Aggressive Cows

Intuition:
We have to place cows within positions given as a input. It means we have to check with minimum distance using which we can place given number of cows within that positions. Here we observe a monotonic functions.
If with distance 1, 2, 3 we can place 3 cows let say and with distance 4 we cannot place then with even greater number like 5, 6, 7 also, we wont be able to place it.
Hence remove the other half means apply binary search.

Steps: -

1. Sort the array and take low as first element value and high as difference of last & first element value.
2. Start looping till low <= high
    a. Calculate mid
    b. canPlaceCows(positions, numberOfCows, mid) then store mid as res & low = mid + 1 (since we have to find largest minimal distance).
    c. ELSE, high = mid - 1;
3. return res.
4. canPlaceCows(positions, numberOfCows, mid) functions -
    a. declare lastPlacedCow as first element & count = 1;
    b. start looping from 1 to n
        i. if (positions[i] - lastPlacedCow >= minDist) then count++ and lastPlacedCow = positions[i];
        ii. if (count == numberOfCows) return true;
    c. Outside loop return false.

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 13: Stacks & Queues:

*******************************************************************************************************

Problem 1: - Implement Stack Using Arrays

Declare top pointer as -1. Write down push, pop, top, isEmpty, size methods to perform various stack operations.

-------------------------------------------------------------------------------------------------------

Problem 2: - Implement Queue Using Arrays


1. Declare front, rear & count as 0. For enqueuing value, add it at rear pointer and increment rear. For giving top value, return value at front pointer. Dequeueing will take place from front pointer.
2. To make it a circular queue, make sure to add or remove element using % operation.
3. For adding value: - arr[rear % maxSize] = x;
4. For removing value: - Return or print arr[front % maxSize] then arr[front % maxSize] = -1; then front++;
5. For printing value in circular queue: - loop i from front to < rear and print arr[i % maxSize]

-------------------------------------------------------------------------------------------------------

Problem 3: - Implement Stack using Queue (using single queue)

-> Naive approach using 2 queues: -
(Only change will be needed for push operation. pop(), top() & isEmpty() operation will remain the same)
1. Create 2 queues q1 & q2.
2. Add elements into q2.
3. Push value *element by element* (means value at the top) from q1 to q2.
4. Swap q1 & q2.

-> Optimized approach using single queue: -
(Only change will be needed for push operation. pop(), top() & isEmpty() operation will remain the same)

1. Simulate single queue only
2. Push element into queue : queue.add(x);
3. Then push again *size - 1* element again by popping from queue.
    a. start looping i from 0 till < size - 1 and queue.add(queue.poll());
This will ensure LIFO.

For pop, use queue.poll();
For top, use queue.peek();
For isEmpty, use queue.isEmpty();

-------------------------------------------------------------------------------------------------------

Problem 4: - Implement Queue using Stack (O(1) amortized method)

Steps: -
1. Create 2 stacks as input and output
2. Push elements into input stack.
3. For pop: -
    a. Check if output stack is empty. If yes then transfer values from input to output stack element by element till input stack becomes empty and then output.pop();
    b. ELSE directly output.pop();
4. For top/peek: -
    a. Check if output stack is empty. If yes then transfer values from input to output stack element by element till input stack becomes empty and then output.peek();
    b. ELSE directly output.peek();
5. Check both the stack and if empty return true ELSE return false;

Here, all operations are performed in O(1) time complexity. Only few pop and top operations will be performed in O(n) in cases of where output stack is empty & we have to perform transferring values from input to output stack.
So scenarios where most of the operations are performed in O(1) complexity & very few in O(N) complexity then they are considered as "O(1) amortized"

-------------------------------------------------------------------------------------------------------

Problem 5: - Check for balanced parentheses

1. Create map which to map closing parentheses with opening parentheses and initialize stack.
2. Convert string to char array.
3. Start looping i from 0 to s.length()
    a. if character is opening parentheses then push it into the stack.
    b. ELSE if check if (stack.isEmpty() || map.get(ch[i]) != stack.peek()) then return false.
    c. ELSE pop the element.
4. return stack.isEmpty();  //After iteration stack should be empty. Based on that return true/false

-------------------------------------------------------------------------------------------------------

Problem 6: - Next Greater Element

-> 1st variant: Non circular array

Intuition: we have to start traversing from back to maintain the elements into increasing order and remove the smaller element from back. Because smaller element cannot be next larger element of any previous elements.

Steps: -
1. Create stack and nextGreaterElement for storing the result index wise.
2. Start looping from n - 1 till >=0
    a. Start while loop to check stack is not empty & element present at top *<=* arr[i] then stack.pop();
    to remove the smaller element as mentioned in intuition
    b. Check if stack is empty then nextGreaterElement[i] = -1;
    c. ELSE nextGreaterElement[i] = stack.peek();
    d. Outside all looping and if statement and within for loop, push array element into stack: stack.push(arr[i]);
3. return nextGreaterElement;


-> 2nd variant: circular array

Intuition: Same as above. Only exception is: Here, we will copying array elements index wise virtually to make an entry into stack and remove smaller element. So that, any greater element in form of circular array will get from the copied array. Hence, starting the loop from 2n - 1.
**Also, i < n condition** : Because we have to store the result for actual array and not of the copied array.
Also, we have started loop from 2n - 1 so let it come in the range of actual array size. This can be checked using i < n.

1. Create stack and nextGreaterElement for storing the result index wise.
2. Start looping from **2n - 1** till >=0
    a. Start while loop to check stack is not empty & element present at top **<= arr[i % n]** then stack.pop();
    to remove the smaller element as mentioned in intuition
    b. check if (i < n) // reason mentioned above
        i. Check if stack is empty then nextGreaterElement[i] = -1;
        ii. ELSE nextGreaterElement[i] = stack.peek();
    d. Outside all looping and if statement and within for loop, push array element into stack: **stack.push(arr[i % n])**;

-------------------------------------------------------------------------------------------------------

Problem 7: - Sort a Stack

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 13: Stacks & Queues : Part - II

*******************************************************************************************************

Problem 1: Next Smaller Element

Same as Next greater element. Only difference is here we will be removing larger element from the stack. If current value of array is smaller than stack.peek() then remove.

Steps: -
1. Create stack and Integer[] nextGreaterElement for storing the result index wise.
2. Start looping from n - 1 till >=0
    a. Start while loop to check stack is not empty & element present at top *>=* arr.get[i] then stack.pop();
    to remove the smaller element as mentioned in intuition
    b. Check if stack is empty then nextGreaterElement[i] = -1;
    c. ELSE nextGreaterElement[i] = stack.peek();
    d. Outside all looping and if statement and within for loop, push array element into stack: stack.push(arr.get(i));
3. return new ArrayList<>(Arrays.asList(nextSmallerElement)); OR new ArrayList<>(List.of(nextSmallerElement));

-------------------------------------------------------------------------------------------------------

Problem 2: LRU cache (IMPORTANT) : (Least accessed node to Recent accessed node from left to right)

Also remember, if accessOrder is true then also most recent accessed node will be at last position.

Steps: -
1. Create LinkedHashMap and size and initialize it into constructor.
2. GET operation: -
    a. Check if key is not present then return -1;
    b. get value from the key and remove that key. Then, add key value pair and return the value. We are removing and adding the pair because in LRU last accessed node comes to the last. (Order: Least access node to recent accessed node from left to right)
3. PUT opertion: -
    a. Check if key is present then remove that key and new key value pair will be added by step 3.c.
    b. Check if (map.size() == size) then get the first key: map.keySet().iterator().next() and remove that key. New key value pair will be added by step 3.c.
    c. Outside both the if statements: Add key value pair passed as an arguments.   //If size is full then step 3.b will remove the least accessed node and 3.c will add new node, if size is not full then step 3.c will get executed directly.

-------------------------------------------------------------------------------------------------------

Problem 3: LFU cache

Here, every put and get operation will be considered as accessed operation. So, we have to maintain the frequency.
Once, map is full we have to reomve the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used (LRU) key would be invalidated.

Steps: -
1. Create 3 different maps:
    a. vals:- cache K and V
    b. counts:- K and counters (frequency)
    c. lists:- Counter and item list
2. Also initialize cap for storing capacity & min = -1 for storing the frequency.

3. GET operation: -
    a. Check if key is not present then return -1;
    b. Get the count from counts map : int count = counts.get(key);
    c. Increase the counter : counts.put(key, count + 1);
    d. Remove the element from the counter to linkedhashset : lists.get(count).remove(key);
    e. When current min does not have any data, next one would be the min : if (count == min && lists.get(count).isEmpty()) then min++;
    f. If next counter value is not available in map, then we should create one with the empty hashSet and then access it. Otherwise, we will get exception.
    g. Add the key in corresponding frequency list : lists.get(count + 1).add(key);
    h. Finally return the value.
4. PUT opertion: -
    a. Check for negative scenario
    b. If key does exist, we are returning from here : vals.put(key, value); then **get(key);** (To mark it as accessed)
    c. If map is full then find the key of least frequency used element and in case of tie find LRU element. int evict = lists.get(min).iterator().next();
    Remove it from all maps
    d. If the key is new, insert the value in all 3 maps and current min should be 1 of course
        vals.put(key, value);
        min = 1;
        counts.put(key, 1);
        lists.get(1).add(key);

-------------------------------------------------------------------------------------------------------

Problem 4:

-------------------------------------------------------------------------------------------------------

Problem 5: Sliding Window maximum

Intuition: We have to maintain the order in decreasing order which means higher element at the top. so, once we receive any element greater than top element it means all element after that will also be smaller. So start removing element from back and empty the queue. Then add this higher element.
This way we are maintaining the decreasing order.
Also, adding from the head and removing from the back.

Steps: -

1. Create res array of n - k + 1 size to store the result and ri = 0 for maintaining the index of res array.
2. Start looping from 0 to n - 1.
3. Remove numbers out of range: if (!queue.isEmpty() && queue.peek() == i - k) then queue.poll();
4. Remove smaller numbers in k range as they are useless:
    while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]) then queue.pollLast();
5. Adding index: queue.offer(i);
6. Start storing the maximum value of window once index i >= k - 1 then res[ri++] = nums[queue.peek()];

-------------------------------------------------------------------------------------------------------

Problem 6: Rotten Oranges (We will be using BFS here)

Layman terms: -
1. Sbse pehle saare coordinate par jaakr orangeCount nikal lenge or rottenOranges ke coordinate ko queue me daal dene.
2. Agr orangeCount == 0 then return 0;
3. minTime, rottenCount ye sb declare kr lenge or all 4 directions me jaane k lye dx & dy
4. Jab tk queue empty nai hojata, size queue ka nikalenge or rottenCount me add kr lenge.
5. Fir saare queue k values pr iterate krenge (i) or usme 4 directions me jaaenge (j).
6. Next x & y coordinate nikalenge. Or ulta condition lagaenge boundary ka OR next grid empty toh nai hai OR next orange rotten toh nai hai.. if yes then continue.
7. Nai toh us ccordinate ko 2 mark krenge and queue me add kr denge.
8. Bahar check kr lenge, agr queue empty nai hai to min++;
9. Bahar saare loops k dekh lenge, return rottenCount == orangeCount ? mintime : -1;

Steps: -
1. We will start looping i & j to find the total count of oranges (orangeCount) and within same loop will add rotten oranges at the start in the queue.
2. If orangeCount == 0 then return 0.
3. Declare minTime, rottenCount as 0. rottenCount will be used to store count of all the rotten oranges and at last we will compare rottenCount with orangeCount. If both are equal then we will return minTime otherwise -1 (which means it's not possible to rot all oranges)
4. Declare dx, & dy for finding distance in all 4 directions.
5. Start looping till queue is not empty and **calculate the queue size and add it to rottenCount** in every iteration.
6. Start loop i within while loop to iterate over rotten oranges coordinates and get point[] as queue.poll().
7. Start loop j within for loop to check all 4 directions of each coordinate(position) of rotten oranges.
8. Calculate x & y for finding 4 directions movement and check boundary conditions along with no rotten oranges/empty grid (ulta condition laganege sab). If found any then continue;
9. Outside if statement, mark the coordinate of fresh orange as rotten grid[x][y] = 2; & add it to queue.
10. Outside both for loops & within while loop, check if queue size is non-zero then minTime++;
11. Outside while loop, return rottenCount == orangeCount ? minTime : -1; as mentioned in step 3.

-------------------------------------------------------------------------------------------------------

Problem 7: Implement Min Stack

Intuition: - Make sure to use LONG while storing value into stack or assigning it to min because range given is 2^31. Also, we are multiplying it to 2. While returning make sure to return .intValue()

-> During push operation: -
a. If stack is empty, directly push the value and assign it as min.
b. If element is smaller than min then, push the modified value in stack as (2 * val - min) and assign actual element as min.
c. If element is greater then min, normal push.

-> During pop operation: -
a. If popped value is lesser than min then it means we have popped out the modified value. So, now min needs to be changed as prev min which can be calcuated as (2 * min - popped_value(which is also a modified value))
b. If popped value is lesser then do nothing as its already popped. No issue

-> During top operation: -
a. If top value is lesser than min then it means we have modified value so return min directly
b. Otherwise return top value

-> During getMin operation: -
a. return min value

=> 2 points to observe: -

-> Why modified_value = 2 * val - min (prev min) will always be lesser than actual value?
val (new element to be added in stack) < min (prev min) then only we are performing this.
val - min < 0
val + val - min < 0 + val //Adding val on both side
2val - min < val
2val - min -> Modified value which will always be

-> How 2 * min - stack.peek() will give the prev min value of the stack?

Since, we have added modified value in stack place of actual minimum value and also assigned actual minimal value to the mini.
So only reshuffling from prev equation. Basically forming
min(prev min) = 2 * val - modified value    //val was assigned as min. Refer push operation b step

-------------------------------------------------------------------------------------------------------

Problem 8: Stock Span Problem

Intuition: We will be storing index of each value in stack since we want consecutive days as Stock spanner. Indexes will help to calculate the span.
We will be removing smaller value indexes while comparing price with current one and will stop if greater price found.

Steps: -
1. We will be creating Stack (for storing indexes) & ArrayList (for storing elements)
2. Add value into list and calculate currentIndex as size() - 1.
3. Check and remove smaller values indexes from stack: while (!stack.isEmpty() && list.get(stack.peek()) <= price)
then stack.pop();
4. Above loop broke because of 2 conditions: -
    a. If stack is empty:
        - It means no value is bigger than current one. So return list.size() as no. of consecutive days. Before returning add current price index into stack for next iteration.
    b. If greater value found:
        - Then get the index at top of stack. Add current price index for next iteration.
        - Return currentIndex - top;    //to get the consecutive days

-------------------------------------------------------------------------------------------------------

Problem 9: - Find the maximum of minimums of every window size (Time exceeded)

Intuition:
1. The idea is to find the minimums from every window size. To achieve this, we can use problem 5 of current section with little tweak.
2. Here, we will remove larger numbers in k range as they are useless (Because we want minimums).
3. Also instead of returning array of minimums, we will return the maximum element of every window size by using max variable.
4. Then, we will storing this max value into maxOfMinimums[] arrays as final ans.

-------------------------------------------------------------------------------------------------------

Problem 10: - The Celebrity problem:

-> Condition: Everyone knows celebrity but celebrity doesn't know anyone. If this condition meet then return id of celebrity otherwise -1.

-> Observation:
if (knows(a, b)) is true -> a cannot be a celebrity.
if (knows(a, b)) is false -> b cannot be a celebrity.

We will use this to solve the problem.

Steps: -
1. Enter all the ids into the stack
2. Start looping till (stack.size() > 1) and check for above observations:
    a. Pop out 2 values from the stack as id1 & id2
    b. if (knows(id1, id2)) is true then stack.push(id2); Else stack.push(id1);
    By the end of loop, we will have only 1 id which can or cannot be a celebrity. Other candidates will get discarded.
3. Pop out that last element as celebrityId outside while loop. Start looping again from i to < n to confirm if its a celebrity id or not
    a. Check if (celebrityId != i && (Runner.knows(celebrityId, i) || !Runner.knows(i, celebrityId))) then return -1.
    //-1 tab return karna hai jab celebrityId or i same na ho, otherwise same person. AND
    //Ya toh celebrity kisiko jaanta ho OR koi bhi ek id celebrity ko na jaanta ho. As per condition mentioned above.
4. return celebrityId;

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 17: Binary Tree: Part-I

*******************************************************************************************************

Problem 1: Inorder Traversal:

-> Recursive approach : base condition : root == null. Otherwise Left-Root-Right

-> Iterative approach:
a. Stack or List create karenge. Infinite loop chalu krenge.
b. If node != null toh stack me node push krenge and move to left.
c. Else pehle check kr lenge if stack.isEmpty() toh break. Nahi toh stack se node pop krenge, uska value list me add krenge and move to right.

-------------------------------------------------------------------------------------------------------

Problem 2: Preorder Traversal:

-> Recursive approach : base condition : root == null. Otherwise Root-Left-Right

-> Iterative approach:
a. Stack or List create karenge. Infinite loop chalu krenge.
b. If node != null toh **list me pehle add kr lenge** then stack me node push krenge and move to left.
c. Else pehle check kr lenge if stack.isEmpty() toh break. Nahi toh stack se node pop krenge and move to right.

-------------------------------------------------------------------------------------------------------

Problem 3: Postorder Traversal:

-> Recursive approach : base condition : root == null. Otherwise Left-Right-Root

-> Iterative approach:
a. 2 Stack or List create karenge. stack1 me root node push kr denge.
b. Jab tak pehla stack1 empty nai hojata tab tak pehla value pop karenge let say root (resuse krenge) , usko stack2 me add karenge. Fir if same root ka left non-null hai so add it into stack1. Same if root ka right non-null hai so add it into stack1.
c. Step b se last me stack1 empty hojaega or stack2 full hojaega.
d. Wapas se while loop jab tak stack2 empty nai hojata and keep popping value and add it into list. This is the final answer.

-------------------------------------------------------------------------------------------------------

Problem 4: In-order Morris Traversal: (Left-Root-Right) Morris traversal also known as threaded binary tree.

Steps: -

Take curr as root node & start looping while curr != null and handle 3 below cases: -
1st case: if left is null, add current node (leftmost node) into list and go right
2nd case: before going left, take left node in prev and make right most node on left subtree connected to current node, then go left
3rd case: if thread is already pointed to current node, then remove the thread. **Add current node (ROOT)** into list and go to right.

-------------------------------------------------------------------------------------------------------

Problem 5: Preorder Morris Traversal: (Left-Root-Right) Morris traversal also known as threaded binary tree.

Steps: -

Take curr as root node & start looping while curr != null and handle 3 below cases: -
1st case: if left is null, add current node (leftmost node) into list and go right
2nd case: before going left, take left node in prev and make right most node on left subtree connected to current node, **add current node (ROOT) into list** then go left
3rd case: if thread is already pointed to current node, then remove the thread and go to right.

-------------------------------------------------------------------------------------------------------

Problem 6: LeftView Of Binary Tree

Intuition: -
We have to take first element which is visible from left side. So, we will apply preOrder traversal. Also, we will be using level to leverage the logic.

Steps: -
1. We will create ds to store the ans and pass 0 as currentDepth of tree to the recursive function.
2. Recursive function:
    a. Base condition : if (root == null) then return;
    b. check if (currentDepth == ds.size()) then add value to ds.  //This check ensure that we are visiting this level of tree for the first so store the value as ans. As this value will be visible first for this level.
    c. go to left subtree with level + 1: findLeftView(root.left, ds, currentDepth + 1);
    d. go to right subtree with level + 1: findLeftView(root.right, ds, currentDepth + 1);

NOTE: - For Rightview of Binary Tree, we will swap the 2.c and 2.d steps. We will move to right subtree first as we want right view and then move to left subtree.

-------------------------------------------------------------------------------------------------------

Problem 7: Bottom View of Binary Tree

Intuition: We have to pick last element for each horizontal distance. Hence, we will use Vertical order traversal. Will also maintain the horizontal distance(hd) from the root.
For root, it should be 0, While moving towards left hd - 1 & towards right hd + 1.

Steps: -
1. Create ds to store ans, queue to store the node & treeMap to store horizontal distance as key and node.data as value.
2. We will mark root.hd as 0 and add root node into queue.
3. Start looping till queue is not empty
    a. Queue se 1 value pop krne ka and assign it to temp, Similarly temp ka hd as tempHd
    b. Add tempHd, temp.data as key value pair in map.
    c. Check agar temp.left null nai hai so calculate hd as temp.left.hd = tempHd - 1; & add it into queue.
    d. Check agar temp.right null nai hai so calculate hd as temp.right.hd = tempHd + 1; & add it into queue.
4. Outside while loop, for loop lagao to get entrySet and add it into ds.
5. return ds;

-------------------------------------------------------------------------------------------------------

Problem 8: Top View of Binary Tree:

Same as Bottom View of Binary Tree. Only diffeence is with step (3.b). Yaha par humko check daalna hai (!map.containsKey()). Agar key exist nai krra hai toh map.put kar hai. Because we want top view here. Toh har horizontal line par jo pehla entry hoga wahi top view hoga.

Bottom view me har horizontal line par jo last last element hoga wo bottom view hoga. Islye isme override hone denge key ko. containsKey() check krne ka jrurat nai hai.

-------------------------------------------------------------------------------------------------------

Problem 9: Preorder inorder postorder in a single traversal:

-> Simple formula: -
Create 3 lists: - preOrder, inOrder & postOrder
Initialize stack with (root, 1). Keep popping value 1 by 1 and check below condition until stack is not empty.
if num == 1; add into preOrder; increment num & push again into stack; check if left available & add into stack.
if num == 2; add into inOrder; increment num & push again into stack; check if right available & add into stack.
if num == 3; add into postOrder;

-------------------------------------------------------------------------------------------------------

Problem 10: Vertical order traversal:

Intuition: We will follow x-y coordinate marking here. We have to print nodes from left most to right most means traversing x coordinate from left to right. Then, for each x-coordinate we have to iterate level wise of tree means y coordinate.
Hence, we will be maintaining a map of map. TreeMap<xPos, Treemap(yPos, PriorityQueue<Values>)>.
PriorityQueue because we want value in sorted order. We are maintaining map of map because duplicates can be present at different level of tree within x-coordinate.

Steps: -
1. Will create Tuple class to store node, row(xPos) & col(yPos).
2. Will declare Queue<Tuple>, map of map TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> & List<List<Integer>> ds to store res.
3. Push root node into queue with row & col as 0.
4. Apply level order traversal and keep adding value into the map data structure.
    - Jab tk queue empty ni hojata tb tk loop chalao.
    - queue se pop kro usme se node, x(row) & y(col) nikal lo.
    - check kro x key hai ya nai. Agr nai hai to create x key with empty TreeMap.
    - check kro x key me y key hai ya nai. Agr nai hai to create y key in x with empty PriorityQueue.
    - x & y key get krke value store kro.
    - check for left and right node. agr non null hai to queue me push kro with x - 1 & x + 1 respectively. y + 1 hoga dono case me.
5. Apna map ready hai ans k lye. Loop lagakr Usme se value fetch kro which will give TreeMap<Integer, PriorityQueue<Integer>> entry.
    - Empty list create kro for every iteration.
    - Fir loop lagakr PriorityQueue<Integer> values fetch kro as nodes.
    - Fir jab tak nodes empty ni hojate tab tk list me add kro. ds.get(ds.size() - 1).add(nodes.poll());
    //ds.size() - 1 -> this will make sure ki ek level ki entry ek hi index pr hori hai list ki

-------------------------------------------------------------------------------------------------------

Problem 11: Root to node path in a Binary Tree

Intuition: -
We will keep adding value into res array and check if its a target value. If yes return true nahi toh left recursive call or right recursive call karo if we are getting true for any of calls toh return true.
Nahi toh last element remove kro and return false.

Steps: -
1. Create res array List<Integer> and pass it as a reference to recursive function.
2. Recursive function:
    - Base condition: if (root == null) return false;
    - Value ko list me add kro and check ki target value hai. If yes return true.
    - Another if condition me left and right recursive call kro. If we get true for any of calls then return true.
    - Agar kuch ni mila. Matlab na root target value hai or na hi uske childrens toh fir remove kro last element ko and return false.
3. return ds.stream().mapToInt(Integer::intValue).toArray();    // List<Integer> -> int[]

-------------------------------------------------------------------------------------------------------

Problem 12: Max width of a Binary Tree

Intuition: -
Max width kisi bhi binary tree ka humko mil sakta hai by subtracting indexes of last and first node + 1 for that particular level.
Indexing mark krne k lye we will be using a formula:
Left side: - 2*i + 1
Right side: - 2*i + 2

Ab isko har level par badhate rahenge toh for larger datasets let say 10^5, it will give overflow error. Toh hum isko avoid krne k lye every level pr, mininmum index nikal lenge or usko queue k har element ke num ko is minimum value se minus krenge. Jisse us node ka left or right index calculate krte waqt i ka minimum value rahega.

Steps: -

1. Create Pair class which will store node and index.
2. Define Queue<Pair>, ans = 0 to store the final address. Add root node into queue with index as 0.
3. Start looping till queue is not empty.
    a. Queue ka size nikal lenge and and is level ka minimum value min me store kr lenge. first & last ko 0 initialize kr lenge.
    b. Start loop i till < size to iterate through each element of queue to mark indexing.
        - Pair nikal lenge. Usse current node mil jaaega in order of left to right since it is queue ds.
        - curr nikal lenge uske index - min se:  **int curr = pair.num - min;** To minimize the indexing.
        - first & last nikal lenge based on i value: - if i == 0 then first = curr. if i == size - 1 then last = curr.
        - Fir left node non null hai toh uska indexing krke queue me add kr denge: queue.add(new Pair(node.prev, curr*2+1));
        - Fir right node non null hai toh uska indexing krke queue me add kr denge: queue.add(new Pair(node.next, curr*2+2));
    c. Find width using formula mentioned above: - ans = Math.max(ans, last - first + 1);

4. return ans;

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 18: Binary Tree: Part-II

*******************************************************************************************************

Problem 1: Level order Traversal / Level order traversal in spiral form
return type: List<List<Integer>>

Intuition: Here, we have to go level wise and add those list of nodes as final result. Hum log level by level jaaenge or uska left and right not null hai to usko queue me add krenge. Next iteration me queue me jitne bhi values honge that will be list for that level.

Steps: -
1. Create List<List<Integer>> res & Queue<Node> queue. Root ko push kr do queue me.
2. Start looping till queue is not empty.
    a. Find queue size and declare ds as empty list everytime.
    b. Start iterating for all the elements in queue every iteration (i from 0 till size)
        - Pop the node at the top from queue and add it into ds.
        - Agar left not null hai so add it into queue.
        - Agar right not null hai so add it into queue.
    c. Outside for loop but within while loop, add ds into res.
3. return res.

-------------------------------------------------------------------------------------------------------

Problem 2: Height of a Binary Tree (Maximum depth of binary tree)

Intuition: Agar root par hai hum so what we will intend to find, 1 + max(l, h) sub tree. Barabar?? To fir pehle move krenge left. Jaise hi leaf node mila to return 0 (This will be our base condition). Then, will move right. Jaise hi leaf node mila return 0. Fir 1 + max(l, h). Aise recursively sub tree ka height find krte hue root tak aaege.

Steps:
1. Base condition: if (root == null) return 0.
2. Left subtree ka height find krne k lye left move krenge: int lh = maxDepth(root.left);
3. Right subtree ka height find krne k lye right move krenge: int rh = maxDepth(root.right);
4. return Math.max(lh, rh) + 1; //As per intuition

-------------------------------------------------------------------------------------------------------

Problem 3: Diameter of a Binary Tree (Longest path between any 2 nodes. It can or cannot pass via root)

Intuition: - We will try to find the longest path by summation of left & right height for all nodes of a tree and keep checking if its maximum. After traversing each node, finally we will get our diameter.
So, we will use code of height of binary try with little tweak.

Steps: -
1. Create an array diameter of size 1 to store the maxi and pass it as a reference to the recursive function.
2. Recursive function:
    - Base condition: if (root == null) return 0.
    - Left subtree ka height find krne k lye left move krenge: int lh = findHeight(root.left, diameter);
    - Right subtree ka height find krne k lye right move krenge: int rh = maxDepth(root.right, diameter);
    - Ab maximum length find krenge by adding lh + rh: **diameter[0] = Math.max(diameter[0], lh + rh);**
    - Will return the height of subtree: - return Math.max(lh, rh) + 1;
3. return diameter[0];

-------------------------------------------------------------------------------------------------------

Problem 4: Check if the Binary tree is height-balanced or not

Intuition: - we will find height of left & right sub tree for each node. Then will find the abs difference and check if its greater than 1 then return -1 else keep computing the height for all nodes.
If tree is balanced then it wont return -1. If at any moment we find that tree is not balanced, we will return -1 and no further computation will take place.

Steps: -
1. We will call recursive function and compare its output. If its -1 return false else return true:
return findHeight(root) != -1;
2. Recursive function:
    - Base condition: if (root == null) return 0.
    - Left subtree ka height find krne k lye left move krenge: int lh = findHeight(root.left);
    - We will check if lh == -1 then return -1

    - Right subtree ka height find krne k lye right move krenge: int rh = findHeight(root.right);
    - We will check if rh == -1 then return -1

    - After finding lh & rh, we will find abs difference if lh and rh. If its greater than 1 then will return -1.
    - At last return the height of subtree: - return Math.max(lh, rh) + 1;

-------------------------------------------------------------------------------------------------------

Problem 5: LCA in Binary Tree

Intuition: We will traverse through each node till we get both nodes whose LCA needs to be found out. If during traversal we reach to null then return null otherwise return root.
Also after iterating to both left & right subtrees, if we have null for both left and right then return null otherwise return the non null node.
After finding both right and left for particular node, if koi bhi moment pr dono node non null rahega then that node will be the answer.

Steps: -
1. Base condition: if (root == null || root == p || root == q) the return root; //Ya to null return hoga to root.
2. Move to left and right to find the subtrees node.
3. Check if left is null then return right.
4. Else if right is null then return left.
5. Else return root.    //both left and right are not null then we found our result.

-------------------------------------------------------------------------------------------------------

Problem 6: Check if two trees are identical or not

Steps: -
1. If both are null then return (p == q);
2. return (p.val == q.val) && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

-------------------------------------------------------------------------------------------------------

Problem 7: Zig Zag Traversal of Binary Tree:

Intuition: - Level order traversal use krenge bcoz iterate same way me karna hai. Only difference is alternate level ulta list me store karna hai. So we will maintain a flag. When its true, store element in normal order and when its false store it into reverse order. Flag value after every level iteration, outside for loop but within while loop we will change the flag value to opposite one.
This will be the only difference.

-------------------------------------------------------------------------------------------------------

Problem 8: Boundary Traversal of Binary Tree

Intuition: - If we see carefully we want root node added into the list then all leftmost nodes then all leaf nodes & at the end all rightmost nodes in reverse direction.
Same thing we will be implementing in the code.
1. Add root node if its not a leaf node.
2. Add all leftmost nodes excluding leaf.
3. Add all leaf nodes using PreOrder.
4. Add all rightmost nodes in reverse direction excluding leaf node.

Steps: -
Same as above.
1. Leaf node ka condition: return root.left == null && root.right == null;
2. Add all leftmost nodes excluding leaf:
    - curr me root.left le lenge. Loop chalu krenge jab tk null nai hojata curr.
    - Check krenge leaf node to nai hai.. Agar nai hai to add it into res list.
    - if (curr.left != null) then curr.left else curr.right

3.Add all leaf nodes using PreOrder:
    - check krenge agar leaf node hai toh add it into res list and return;
    - if (root.left != null) toh left me move krenge.
    - if (root.right != null) toh right me move krenge.

4. Add all rightmost nodes in reverse direction excluding leaf:
    - curr me root.right le lenge. ek temp list create krenge Loop chalu krenge jab tk null nai hojata curr.
        a. Check krenge leaf node to nai hai.. Agar nai hai to add it into temp list.
        b. if (curr.right != null) then curr.right else curr.left
    - Loop k baahar ulta condition wala for loop chalaenge bcoz reverse direction me res list me add krna hai.

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 19: Binary Tree: Part-III

*******************************************************************************************************

Problem 1: Maximum path sum

Intuition:
Traverse through every node and calculate leftPathsum and rightPathSum. Then calculate maxi by summing current node with both path sum.
During every node traversal in subtree return the node.val + max(leftPathsum, rightPathSum). This max will ensure whether to take a left path or right path in an elongated subtree.

Steps: -
1. Create maxi[] for storing the ans and pass it as reference to the recursive function.
2. Recursive function:
    - Base condition: if root is null return 0;
    - Calculate leftPathSum: int leftPathSum = Math.max(0, findMaxSum(root.left, maxi));
    // Math.max(0, ..) is used to avoid negative sum. If sum we get as -ve then return 0. Bcoz -ve sum wont maximize the sum.

    - Calculate rightPathSum: int rightPathSum = Math.max(0, findMaxSum(root.right, maxi));
    // Math.max(0, ..) is used to avoid negative sum. If sum we get as -ve then return 0. Bcoz -ve sum wont maximize the sum.

    - Calculate maxi: maxi[0] = Math.max(maxi[0], root.val + leftPathSum + rightPathSum);
    - return root.val + Math.max(leftPathSum, rightPathSum);    //Reason mentioned in intuition above.

-------------------------------------------------------------------------------------------------------

Problem 2: Construct Binary Tree from inorder and preorder

Intuition:
Preorder : Root Left Right & Inorder : Left Root Right

Preorder arr se jo bhi pehla value rehta hai that will be root. Toh usko root bana lenge. Fir Inorder array me wo root value search krte hai. And us root ka left element will be part of left sub tree and right wala will be part of right sub tree.
Toh Preorder me bhi Root pehla element se aage jitna Inorder ke left me elements hai same number of elements Preorder se bhi le lenge for further computation.  --> This is for building left sub tree.

For right subtree: - 1st element + Inorder k left wale element + 1 k baad se Preorder array k end tak consider krenge.

Har traversal me yahi problem ko sub problem me convert krna hai. Naya set of Preorder & Inorder banaenge for building left and right sub tree from root.

Steps: -
1. Create map and insert all array elements of Inorder inside map.
2. Pass everything to recursive function :
int[] preorder, int preStart (as 0), int preEnd (as length - 1), int[] inorder, int inStart (as 0), int inEnd (as length - 1), Map<Integer, Integer> map
3. Recursive function:
    - Base condition : if (preStart > preEnd || inStart > inEnd) return null;   //If preorder or inorder arr gets empty
    - Preorder ka pehle element lekr usko root bana denge (root).
    - Map me se is root value ka index nikal lenge (inRoot). Then, nums on left calculate kr lenge :
    int numsLeft = inRoot - inStart;

    - Fir left or right sub tree k lye recursive call by splitting Inroder & Preorder using 2 pointers each.
    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, inorder,
                inStart, inRoot - 1, map);
    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, inorder,
                inRoot + 1, inEnd, map);

    - return root;
4. return root;

-------------------------------------------------------------------------------------------------------

Problem 3: Construct Binary Tree from inorder and postorder

Postorder : Left Right Root & Inorder : Left Root Right

Same as problem 2 above. Bas is baar aage ki jagah apan piche se value pick krenge for root because postOrder me root last me rehta hai.
While dividing pointers. Inorder k lye same rahega..
-> Postorder ke liye:
For left elements: hum postStart se **postStart + numsLeft - 1** krenge (Basically first utne numbers will be left side as PostOrder me start k left elements hote hai.)
For right elements: hum **postStart + numsLeft** se postEnd - 1 tak pick krenge

Rest code and steps will be same. Only postorder related pointers will differ. And node will be created using last node of postOrder array.

-------------------------------------------------------------------------------------------------------

Problem 4: Symmetric Binary Tree

Intuition:
If considerin the left and right of root they should be same. But uske baad if we see in mirror left will become right from the centre.
So, hum isi ko follow krenge. We will go left and right simultaneously and check if values are equal or not. Agr equal hai in all traversal toh symmetric otherwise non-symmetric.

Steps: -
1. Base condition : if (left == null || right == null) return left == right;
2. check dono value equal hai ya nai. If no then return false;     //matlab non-symmetric
3. return checkSymmetric(left ka left, right ka right) && checkSymmetric(left ka right, right ka left);

-------------------------------------------------------------------------------------------------------

Problem 5: - Flatten Binary Tree to LinkedList

Condition:
1. The "linked list" should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.
2. The "linked list" should be in the same order as a pre-order traversal of the binary tree.

Intution: Since it is mentioned that it should be  pre-order traversal, toh preOrder me after rightmost elemnent of left sub tree, iteration goes to the right element of root node. Isi observation ka use krenge hum.
Morris Traversal: Agar yaad kre toh hum left node ke right most node tak jaate hai or thread banate hai root node se.
Same cheez yaha krenge. Instead of pointing thread to root, we will tie thread to root.right

Steps: -
1. Declare curr pointing to root node.
2. Start looping till curr != null
    a. **Check if curr.left != null**
        - prev me root ka left le lenge.
        - while loop lagakr iterate krenge jb tk left (prev) ka rightmost element ni mil jaata.
        - Rightmost node ka right null hoga usme, curr.right ka address daal denge.
        - curr.right me curr.left daal denge.      //because ab curr ka next element curr.left hoga after this link.
        - Then **curr.left = null;**
    b. curr = curr.right;

-------------------------------------------------------------------------------------------------------

Problem 6: - Check for Children Sum Property (root node will be summation of all child nodes)
Condition: You cannot decrement the value however you can increment value by +1 for any number of time.

Intuition: -
1. Given condition ka fayda uthaaenge. kam ni kr sakte to sum value ko badhaaenge. Hum left or right node k data ka sum lenge. Agar sum > root ka data then root.data ko sum assign kr denge.
2. Agar sum < root ka data toh dono child ko root.data assign kr denge.    //Isse kya hoga ki while going down hum values badhate jaaenge jisse wapas aate waqt root ka value badh jaaaye decrement krne ka jrurat hi na pade.
3. Then move left.. fir move right..
4. Now backtrack. left non null toh sum it into total. Right non null hai to sum it into total.
5. Fir check kro agr leaf node nai hai wo, means both left OR right dono me se koi non null hai to assign root.data = total;

-------------------------------------------------------------------------------------------------------

Problem 7: - Mirror Binary tree

Observation: Left becomes right and right becomes left -> Mirroring
So, hum kya krenge left ke nodes me right ko swap krte jaaenge or right me left nodes ko swap krenge.
Swap krne k lye left node ko pehle hi temp me rakh lenge.

Base condition: - if (node == null) return null;
Node temp = node.left;
node.left = mirrorNode(node.right);
node.right = mirrorNode(temp);
return node;

-------------------------------------------------------------------------------------------------------

*******************************************************************************************************

Day 20: Binary Search Tree

*******************************************************************************************************

Problem 1: Populate Next Right pointers of Tree
Conditions: -
Here, we have to connect all nodes on each level to its next node. Or last node rahega agar toh uske next me null fill krna hai. By default, sbka next pointer is null.

Intuition: -
Har level ke current node k next me next node ka address fill karna hai. Toh humko right node ka address chahiye. Since level wise jaana hai toh use level order traversal. Plus right node pehle chhahiye to hum reverse kr denge. Means right node pehle store krenge then left node. -> Infer to reverse level order traversal.

Steps: -
1. Cover negative scenario.
2. Create queue and push root into queue.
3. Start looping till queue is not empty
    - Declare Node rightNode = null; //To store right node address.
    - Start looping i (0 to size)
        a. Queue se value poll krenge ans curr me store krenge.
        b. curr.next = rightNode    //Last node k lye null jaaega fulfilling the condition
        c. rightNode = curr     //Storing curr into rightNode. Jisse next iteration me iske left ka value pop hoga jiske next me humko right ka address daalna hai.. wo rightNode se mil jaaega and this will continue for all iteration.
        d. Agr curr.right non null hai to **push right node first and then left node**
        //Sirf curr.right non null check krre hai bcoz mentioned hai problem me ki it will be perfect binary tree and all levels will be completely filled.
4. return root.

-------------------------------------------------------------------------------------------------------

Problem 2: Search given Key in BST

Intuition: BST hai.. toh agr key chota hai toh left side me jaao or bada hai to right side me jaao.

Steps: -
while (root != null && root.val != val) {
    root = val < root.val ? root.left : root.right;
}
return root;

-------------------------------------------------------------------------------------------------------

Problem 3: Check is a BT is BST or not

Intuition: Left pr root se chota value hona chahiye and right me root se bada value hona cahhiye. But jaise jaise tree me niche jaaenge we dont have to only care about chota and bada wrt to root but also about range.
Toh hum minValue or maxValue define krenge as RANGE. Long.MIN_VALUE, Long.MAX_VALUE
Jab bhi left traverse krenge tb range should be (minVal, root.val) and for right it should be (root.val, maxVal).
return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);

Iske pehle -ve scenario check kr lenge if root is null return null. Or boundary condition ki root.val -> maxVal or minVal k bich me hi hai.

 -------------------------------------------------------------------------------------------------------

 Problem 4: Construct BST from preorder traversal

 Intuition: Problem 3 ka approach use krenge. Yaha pr range me khelenge. Par yaha sirf upper bound se khelenge.

 Steps: -
 1. Ek upper bound define kr lenge or ek reference variable jo arr ko traverse krega. Will pass this to recusrive function
 2. Recursive function:
    - Base condition: - if (i[0] == preorder.length || preorder[i[0]] > bound) return null;
    //preorder[i[0]] > bound -> Ye make sure krega ki agr koi value range k bahar hai or right ya left me plant nai kr sakte to null return krega.
    - Node bana lenge arr se value pick krke.
    - Fir root.left k lye recursive function call krnenge with bound as root.val.   //Left me jaane k lye upper bound would be root only and lower bound node ka value khud rahega. Toh islye lower bound ka jrurat nai hai.
    - Then root.right k lye recursive function call krnenge with bound as bound.   //Bcoz hum upper bound liye hai.
    - return root;

-------------------------------------------------------------------------------------------------------

Problem 5: - Find the inorder predecessor/successor of a given Key in BST.

Successor: -
Successor matlab key value se just 1 bada value (immediate greater)

Declare successor & predecessor as -1.

1. Start looping till root != null
2. check krenge agr key >= root.val se toh move right.
3. Jaise hi root.val bada hua, successor variable me root.val store kro and then move to left. Ab left node root ban jaaega. Toh loop me fir step 2 execute hoga
//Left me jaaene ka reason because uske right me or bade values honge which cannot be immediate greater.

Predecessor: -
Predecessor matlab key value se just 1 chota value. (immediate smaller)

1. Start looping till root != null
2. check krenge agr key <= root.val se toh move left.
3. Jaise hi root.val chota hua, predecessor variable me root.val store kro and then move to right. Ab right node root ban jaaega. Toh loop me fir step 2 execute hoga
//Right me jaaene ka reason because uske left me or chote values honge which cannot be immediate smaller.

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 20: Binary Search Tree - Part II

*******************************************************************************************************

Problem 1: Floor in BST:

Same as finding predecessor. Problem 5 of previous section.

-------------------------------------------------------------------------------------------------------

Problem 2: Ceil in BST:

Same as finding successor. Problem 5 of previous section.

-------------------------------------------------------------------------------------------------------

Problem 3: Find K-th smallest element in BST

Apply inorder traversal (Left Root Right) using iterative approach. Bas bich me ek condition add karna hai jaha pop karte waqt hum count decrement krenge or check karenge if its == 0. Then, wahi se node ka value return kar do.

-------------------------------------------------------------------------------------------------------

Problem 4: Find K-th largest element in BST

Apply reverse inorder traversal (Right Root Left) using iterative approach. Bas bich me ek condition add karna hai jaha pop karte waqt hum count decrement krenge or check karenge if its == 0. Then, wahi se node ka value return kar do.

-------------------------------------------------------------------------------------------------------

Problem 5: Find a pair with a given sum in BST (Time exceeded)

Create class BSTIterator (Refer next problem) having both functionality next() & previous.
However, prev is managed using isReverse flag. -> true for prev & false for next.

- Now, in actual class create 2 objects (l & r) which will take isReverse as parameters.
- get i & j using l.next() & r.next()
- Start looping till i < j
    - check if i + j == k return true
    - else if (i + j < k) i = l.next();
    - else j = r.next();
- return false.

-------------------------------------------------------------------------------------------------------

Problem 6: BST Iterator

Yaha humko BST Iterator design karna hai. Humko root node diya rahega. Or ye humko inorder traversal of BST par design karna hai. We have to implement 3 stuffs:
1. Constructor call hai
2. hasNext() -> If stack empty nai hai toh return true else false.
3. next() -> Jo bhi inorder k hisab se value hoga wo return krna hai.

- ek stack initialize kar lenge.
1. Constructor call me hi hum root ko lekr saare left wale element store kr lenge. (pushAll() method bana lenge)
for (; node != null; stack.push(node), node = node.left);

2. hasNext() - check kr lenge if stack is empty or not: return !stack.isEmpty();

3. next():
    - Stack se node pop karenge.
    - Or fir us node ke saare left element stack me push kr denge using pushAll(node.right);
    - return node.val;

To find previous, we would have to add all rightmost node first. And after popping go to left and again add rightmost node of that left node. This will be the only change.

-------------------------------------------------------------------------------------------------------

Problem 7.1: Size of largest BST in Binary Tree

BST me largest value from left < root.val < BST me smallest value from right (Iska matlab humko left or right side computed chahiye. So, we will use postorder traversal)
Yahi main funda yaad rakhna hai.

Steps:
- Ek NodeValue krke class bana lenge jisme min, max, size maintain krenge constructor se
1. Agr root == null hai so return new NodeValue(Integer.MAX_VALUE, Integer.MIN_VALUE, 0); min ko max rakhenge or max ko min jisse easy comparsion hojaye.
2. move left and right.
3. Check for above intuition: if (left.maxNode < root.val && root.val < right.minNode)
    return new NodeValue(Math.min(left.minNode, root.val), Math.max(right.maxNode, root.val),
                    left.maxSize + right.maxSize + 1);
4. For invalid BST: -
    return new NodeValue(Integer.MIN_VALUE, Integer.MAX_VALUE,
                Math.max(left.maxSize, right.maxSize));
//Min ko ekdum kr do or max ko ekdum max jisse intuition humesha false ho. Bcoz invalid bst humko nahi compute krna hai

-------------------------------------------------------------------------------------------------------

Problem 7.2: Maximum sum of largest BST in Binary Tree

Same as above intuition. Isme ans krke reference carry karenge.
- Ek NodeValue krke class bana lenge jisme isBST, max, min, sum maintain krenge constructor se
1. Agr root == null hai so return new T(true, Integer.MIN_VALUE, Integer.MAX_VALUE, 0); min ko max rakhenge or max ko min jisse easy comparsion hojaye.
2. move left and right.
3. Boundary condition check krenge to find if invalid bst and return new T();
4. For valid BST: -
    final int sum = root.val + left.sum + right.sum;
    ans[0] = Math.max(ans[0], sum);
    return new T(true, Math.max(root.val, right.max), Math.min(root.val, left.min), sum);

-------------------------------------------------------------------------------------------------------

Problem 8: Serialize and deserialize Binary Tree

-> For Serialization: -
We will be appying level order traversal and adding n for null and delimiter will be space. Since, we are adding n for null, we will not check for left.null or right.null. Instead will directly add value into the queue. Only we will check with node == null then res.append("n "). Otherwsie res.append(node.val + " ");

-> For Deserialization: -
1. We will again be declaring queue and convert string into string[] using split method.
2. With help of first value we will create root and add it into queue. //Everytime while creating a node, add it into array.
3. Now start looping i from (1 to length)
    - Pop the node (parent) from queue.
    - Check if (!values[i].equals("n")) then create node (left) using values[i] and add it into parent.left. Also add it into queue.
    - Check if (!values[**++i**].equals("n")) then create node (right) using values[i] and add it into parent.right. Also add it into queue.
4. return root;

//Dont forget to wrap values[i] & values[0] in Integer.parseInt()

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 22: Graph - Part I

-> Coding ninja me edges[][] diya hai sirf toh create adjacency matrix.

public static int[][] createAdjMat(int vertex, int[][] edges) {

        int[][] adjacency_matrix = new int[vertex][vertex];

        for (int i = 0; i < edges[0].length; i++) {
            adjacency_matrix[edges[0][i]][edges[1][i]] = 1;
            adjacency_matrix[edges[1][i]][edges[0][i]] = 1;
        }

        return adjacency_matrix;
    }

-> Agar edges[][], vertex (n), edges(m) sb mentioned hai toh create adjacency list.

ArrayList<ArrayList< Integer >> adjList = new ArrayList<>(n + 1);   //1 to N hai vertices
        for(int i = 0; i <= n; i++){    //for vertices
            adjList.add(new ArrayList<>());
        }

        for (int i = 0; i < m; i++) //for edges
        {
            adjList.get(edges[i][0]).add(edges[i][1]);
            adjList.get(edges[i][1]).add(edges[i][0]);
        }

*******************************************************************************************************

Problem 2: - DFS traversal

1. Isme pehle list (for storing result) & visited array(to check if node is visited or not) bana lenge.
2. Multiple component ke lye loop lagaenge i (0 to V) and if wo visited nai hai toh call recursive function.
3. Recursive function: -
    - Add kar lo list me ye node and mark it as visited.
    - for loop lagao to go through all adjacent element (for (Integer it : adj.get(node))) and loop k andar check kro if that node is unvisited then call dfs with that node.    //yaha hum adjacent nodes pr jaaenge 1 by 1 or jb visited hojaega saara to waps aaenge to iterate through next adjacent element.

-------------------------------------------------------------------------------------------------------

Problem 3: - BFS traversal

-> BFS Traversal: -

Traverse karenge after storing value in queue for multiple components. Jab tak queue empty ni hojata for unvisited nodes.

1. Isme pehle list res(for storing result) & visited array(to check if node is visited or not) bana lenge.
2. first node 0 ko push kr denge and mark it as visited.
3. Loop lagaenge jab tak queue empty nai hojata
    - Poll krenge node. and add it into list.
    - Adjacent node ke liye loop lagaenge and if those nodes are unvisited then mark it as visited & add it into queue.
4. return res;

-------------------------------------------------------------------------------------------------------

Problem 4: - Detect A cycle in Undirected Graph using BFS

-> BFS Traversal: -

Traverse karenge after storing value in queue for multiple components. Vertex or parent ka mapping rakhenge using Node class or bfs traversal apply karenge for unvisited nodes. In case, koi vertex visited mila to check karenge ki if parent != i (current vertex of adjacency list). Agar != raha matlab cycle detected. Or agar == raha to matlab adjacent node hai. Move ahead for detection.

-------------------------------------------------------------------------------------------------------

Problem 5: - Detect A cycle in Undirected Graph using DFS

Traverse karenge using recursion for multiple components. Vertex or parent ka mapping rakhenge or dfs traversal apply karenge for unvisited nodes. In case, koi vertex visited mila to check karenge ki if parent != i (current vertex of adjacency list). Agar != raha matlab cycle detected. Or agar == raha to matlab adjacent node hai. Move ahead for detection.

-------------------------------------------------------------------------------------------------------

Problem 6: - Detect A cycle in Directed Graph using DFS

Traverse karenge using recursion for multiple components. Isme 2 array maintain karenge -> visited and dfsVisited. For every visited node dono ko true karenge. Or jaise hi recursion particular vertex ka khatam hota rahega, thik pehle dfsVisited array me usko false mark kar denge. Or DFS traversal using recursion apply karenge. In case, koi vertex visited mila to check karenge ki if (dfsVisited[vertex]) check karne k liye ki wo traversing same direction/vertex se kar raha hai ya nai. Agar true raha matlab cycle detected. Or agar false raha to matlab wo is direction se nai aaya hai.. Move ahead for detection.

-------------------------------------------------------------------------------------------------------

Problem 8: - Topological sort (DAG) using DFS algo

Topological sort means linear ordering of vertices. If we have edges from u -> v then u should appear before v. Their can be multiple topo sort for single graph.
Directed because linear ordering of vertices hai. Or u should be before v. directed nai hoga to pata ni chalega kaun pehle hai or kaun badme.
Acyclic because agr cycle create hogya toh u should before v concept contradict hoga because cycle se dependency create hojaega.

Traverse karenge using recursion for multiple components. Isme only difference is ek stack maintain karenge. DFS apply krne k bad agar recursion us particular vertex ka khatam hone aara to khatam krne k thik pehle usko stack me push krenge. Aise after all traversal, stack me jo set of values rahega wo topo sorted rahega.

-------------------------------------------------------------------------------------------------------

Problem 9: - Topological sort (DAG) using BFs algo  (Kahn's algorithm)

Intuiton:
If we have edges from u -> v then u should appear before v. Toh hum us node se chalu krenge jiska koi in-degree nai hai. Matlab wo humesha linear ordering me pehle rahega. Fir hum adj nodes dhundhenge or 1 se decrement karenge means hum is node ka dependency hata rhe hai. Toh check krenge adj nodes ka ki in degree 0 hua kya? if yes toh add kro queue me.

Traverse karenge after storing value in queue for multiple components. Isme pehle in-degree of each node calculate karenge or fir zero in-degree wale vertex ko queue me add kar denge or uspr BFS start krenge. Jo adjacency list se adjacent node milta jaaega uska in-degree decrement karenge 1 se and check karenge us particular vertex k lye hi ki zero hua kya? Agr 0 hua to add in queue and keep applying bfs traversal until queue becomes empty.

-------------------------------------------------------------------------------------------------------

Problem 10: - Detect A cycle in a Directed Graph using BFS

Apply Kahn's algorithm. Only change : find node count after topo sort and compare it with noOfVertices.
If count is not same then graph contains a cycle. Bcoz Topological sort is DAG(directed acyclic graph).
If graph will contain a cycle then it wont be able to have all nodes after topo sort.
Its a hack we are using here. In interview prefer DFS approach for finding cycle in directed graph.

-------------------------------------------------------------------------------------------------------

Problem 11: - Number of islands (2 variations: 4 directions & 8 directions)

- This question is based on Connected Component. Number of island find karna hai matlab number of connected component dhundhna hai. We know dfs/bfs traversal. Koi bhi traversal apply kr sakte hai.
- 2 variants hai: -
    a. 4 directions: -
        - count variable declare karenge or isme visited k lye matrix nai banaenge alag se. Same matrix use krenge or jaha 1 rahega bfs call me usko queue me add krke usko 0 mark kr denge.
        - 2 for loop laganege to traverse each coordinate of matrix and jaha pr bhi grid ka value 1 hoga call bfs. (This will cover all connected component wrt this coordinate). Or loop me count ko increment kr denge.
        - bfs function me queue me coordinate add kr denge (using Pair class OR int[]) or us cooridnate ko 0 mark kr denge.
        - dx & dy define kr lenge for moving in 4 directions.
        - Loop lagaenge jab tk queue empty ni hojata or poll kr lenge queue se jo bhi top pr rahega. usme
        - Fir for loop lagenge 0 to < 4 and x , y calculate krenge using int x = point[0] + dx[k]; & int y = point[1] + dy[k];
        - Boundary condition check krenge + grid ka value agr 1 hai or agr sab barabar hai toh, wo grid ka value 0 mark kr denge or x,y pair ko queue me add kr denge.

    b. 8 directions: -
        - Everything will be on similar lines as mentioned above. Bas traversing in 4 directions ka logic halka sa tweak hoga to traverse in 8 directions
        - agr hum eight directions k movement nikale toh humko samjhega ki row to col hum -1 to +1 movement krre hai.
        - Isiko pakadkr apna 2 for loop lagega while loop k andar hi.. Or ek pair ko poll krne k bad. Jisko reference lekr hum 8 directions me move krenge.
        - **Ek delRow or dursa delCol which will traverse from -1 to <=1.** (Only change in above logic)
        - Andar ka waps sab same upar jaisa. New x,y calculate hoga : int nrow = row + delRow; int mcol = col + delCol;
        - - Boundary condition check krenge + grid ka value agr 1 hai or agr sab barabar hai toh, wo grid ka value 0 mark kr denge or x,y pair ko queue me add kr denge.

Ek or variation tha 4 direction wale me jaha adjacency matrix diya tha to hum usko adjacency list me convert kiye uske bad normal dfs traversal apply krke count find kr liye.

-------------------------------------------------------------------------------------------------------

Problem 12: - Bipartite Check using BFS

Definition: A graph can be colored using 2 colors such that no two adjacent nodes have same color.

- Same bfs traversal apply krke ek ek node traverse karenge and usko 1/0 se color kranege using (color[adjNode] = 1 - color[node];)
- adjNode traverse krenge & adjNode ka color check krenge. Agar -1 hai toh color change krenge or queue me add krenge.
- Par agr color -1 nai hai, it means colored hai. else if me uske parent node se color match krenge. Agar same nikla matlab adjacent nodes have same color, toh false return kr denge.
- After all looping, we will return true. Bcoz agr Bipartite nai rahega to it would have return from else if condition.

-------------------------------------------------------------------------------------------------------

Problem 13: - Bipartite Check using DFS

1 Same dfs traversal apply krke ek ek node traverse karenge and usko 1/0 se color kranege using (color[node] = 1 - color[currentColor];)
2 Every iteration me color change krenge. (DFS me currentColor apan as a parameter le lenge)
3 Fir adjNode traverse krenge & adjNode ka color check krenge. Agar -1 hai toh recursive function call krenge if statement lagakr. jisme currentNode ka color as a parameter bhej denge along with adjNode. (Step 2 se color change hoajega). Or ulta condition lagakr false return karenge. Jisse kisi bhi iteration me bipartite ni mila to false return kr denge seedha.
4 Par agr color -1 nai hai, it means colored hai. else if me uske parent node se color match krenge. Agar same nikla matlab adjacent nodes have same color, toh false return kr denge.
5 After all looping, we will return true. Bcoz agr Bipartite nai rahega to it would have return from else if condition.

-------------------------------------------------------------------------------------------------------
*******************************************************************************************************

Day 22: Graph - Part II

*******************************************************************************************************

Problem 1: Strongly Connected Component(using KosaRaju’s algo)

This algorithm is used to identify strongly connected components.
SCC -> Each node will get visited if you start from any node within that component.
for eg: if graph consist of edges: 1 -> 2 -> 3 -> 1 && 2 -> 4 -> 5
SCC will be :- 1 2 3
SCC: - 4 (bcoz of non cyclic)
SCC: - 5 (bcoz of non cyclic)

It can be found out using 3 steps:
Step 1: Sort all nodes in order of their finishing time -> Topological sort -> refer problem 8 of previous section
Step 2: Reversing the edge direction -> Finding transpose
    - 2 for loop lagaenge. 1st loop(i) to iterate all nodes & second loop to iterate on adjacent node for given i. Edge ko reverse krenge using
        for (int it : adjList.get(i)) {
                transpose.get(it).add(i);   //Directed graph hai so single swap
        }
    //**Isme hum first loop k andar pr second loop k bahar visited[i] = 0 kr denge becoz 3rd step me use krna hai.
    //Step 1 me wo visited hogya hoga.. islye waps non-visited krna hai.**
Step 3: Do the DFS according to the finishing time -> DFS on nodes we got after topo sort in step 1.
    - Stack values pr iterate krenge poll krke. Or agr visited nai hai toh call dfs.
    - Ek ds carry krenge to add values of SCC in list.
    - Jab dfs call se return aaenge last me to resultant list me add kr do ds.

-------------------------------------------------------------------------------------------------------

Problem 2: Dijkstra algorithm (for finding shortest path ) : It works only in cases of positive edge weights.

1. Sbse pehle ek Node class banaenge which will contain v and weight. Uska cosntructor or getter method bana lo. And comparator implement kro such that it should arrange nodes in increasing order of their weight. (Minimum distance should reside at the top)
2. Given data ko adjacency list me convert kro such that ArrayList<ArrayList<*Node*>>. This indicates u ka mapping v se along with distance //Undirected graph hai to ulta bhi add krenge.. v ka mapping u along with distance.
3. PriorityQueue<Node> maintain kro jiske constructor me vertices k sath comparator pass kr do.
4. dist[] array create krke sbko max value define kr lete hai.
5. dist[source] = 0 kr denge or queue me source with 0 distance add kr denge to perform bfs: queue.add(new Node(source, 0));
6. Ab jab tk queue empty nai hojata tab tak:
    a. queue se node poll kro.
    b. Adj node(it) find kro or fir check kro
        if(node.getWeight() + it.getWeight() < dist[it.getV()]). If yes toh dist[it.getV()] = node.getWeight() + it.getWeight();
        or fir isko hi queue me add kr do with latest distance of V: queue.add(new Node(it.getV(), dist[it.getV()]));
7. dist[] array me apna ans ready hai. ArrayList create krke usme copy krdo and return it.

-------------------------------------------------------------------------------------------------------

Problem 3: Bellman-Ford Algorithm (for finding shortest path ) : This overcomes the problem of Dijikstra algo but will not work in case of negative weighted cycle.

1. Dijikstra algorithm doesn't work for negative weighted graphs.
2. Bellman ford overcomes this problem to work with negative weighted edges.
3. It will not work only in case of negative weighted cycle. However, it also help to detect negative weighted cycle.
4. We have to relax all the edges by N - 1 times. After relaxing N - 1 times, distance will have the shortest path.
formula: - if d(u) + (weight to reach to v) < d(v) then d(v) = d(u) + (weight to reach to v)
5. However, if one more iteration further reduces the weight of edges it means that graph contains negative weighted cycle.
6. Reason for N - 1 relaxation: - because that is the longest path, graph can have to reach from src to farthest node.
7. for eg: 1 -> 2 -> 3 -> 4 -> 5 : - longest path to reach from 1 to 5 contains exactly N - 1 edges.

Steps: -
1. Pehle Node class bana lenge jaha u, v, weight set karenge.
2. edges list ko node list me convert kr lenge: - ArrayList<Node>.
3. dist array create kr lenge and source ko 0 mark kr denge.

4. Loop chalaenge for n - 1 times or loop ke andar 1-1 node pick krenge using enhance for loop or condition check krenge: - if (**dist[node.getU()] != 1e9** && dist[node.getU()] + node.getWeight() < dist[node.getV()]) or agr ye satisfied hota hai toh value assign kr denge.   //infinity - (-ve edge weight) ~ infinity but code wise wo consider ni hoga. Islye ye check important hai dist[node.getU()] != 1e9

5. After relaxing n - 1 times, ek flag declare kar lenge. Fir ek or baar relax karenge as per explanation above. Waps same condition apply kar lenge or agr waps distance reduce hua matlab cycle detected. Mark flag as true and break the loop.
6. Based on flag value return kar denge.

-------------------------------------------------------------------------------------------------------

Problem 5: MST using Prim’s Algo
Somewhat similar to Dijkstra's algorithm

1. We will maintain 3 arrays: -
    a. key : Stores the weight of vertices  -> Initialize it with max value
    b. parent : Maintains Parent of vertices for final MST  -> Initialize it with -1
    c. mst : Vertices considered for MST    -> by default false
2. Node class banao or input ko u, v and weight k form me convert krke adjacency list maintain kro for undirected graph.
3. PriorityQueue declare kro with comparator which will arrange nodes in increasing order of their weight.
4. Since 1-based indexing, key[1] = 0 and queue.add(new Node(1, key[1]));
5. Loop chalao jab tak queue empty ni hojata
    a. Topmost value pop kro .getV and store it into u. iska mst[u] = true mark kro.
    b. Fir adjacent nodes traverse kro and check kro
        - if (!mst[node.getV()] && node.getWeight() < key[node.getV()]) then,
        Minimal value assign kro key[node.getV()], corrsponding parent me u daalo nd queue me value push kro.
        key[node.getV()] = node.getWeight();
        parent[node.getV()] = u;
        queue.add(new Node(node.getV(), key[node.getV()]));
6. Ab apne ko output me ArrayList<ArrayList<Integer>> return krna hai in form of list of u -> v -> w. Ans upr ready hai all 3 arrays me. Usko isme set krna hai.
7. Loop chalaenge (*2* <= n) ///2 se Because 1 is source so, it won't have any parent.
    - ArrayList<Integer> ds declare krenge.
    - ds.add(parent[i]);
      ds.add(i);
      ds.add(key[i]);
    - add ds in res.
8. return res.

-------------------------------------------------------------------------------------------------------

Problem 6: MST using Kruskal’s Algo

It follows Disjoint set algorithm along with Path compression.
findParent() and union() are operation performed in Disjoint set algorithm
Application of Disjoint set algorithm :
1. Kruskal's algorithm 2. Finding if both nodes belong to same component or not.

Steps: -

1. First we will sort all edges in increasing order of their weight
2. Declare parent & rank array. Initially declare parent vertex of each vertex as itself initially. For eg 1 -> 1, 2 -> 2, 3 -> 3 etc..
2. After that we will iterate through all nodes and perfrom following steps: -
    a. Check parent of u (u) & parent of v (v) as they should not be equal    //Otherwise cycle will be formed.
    b. Add weight to costOfMst variable.
    c. Check rank u & v & attach the lower rank node to higher rank node so that height of tree doesn't increase
    d. In case of similar rank, we can attach any node to anyone. Also, in case of similar rank of PARENT, increase the rank of node with whom we are attaching the node.
3. return costOfMst;

-> findParent() : -
if(node == parent[node]) { return node; }
return parent[node] = findParent(parent[node]); //Path compression

-> findUnion(): -
a. Parent find kr lo u & v ka as u & v (reusing the variable)
b. Attach the lower rank node to higher rank node so that height of tree doesn't increase.
    - if (rank[u] < rank[v]) { parent[u] = v; }
    - else if (rank[v] < rank[u]) { parent[v] = u; }
    - else parent[v] = u; rank[u]++;
    //in case of similar rank of PARENT, increase the rank of node with whom we are attaching the node.
    //Here, we are attaching v with u. So, parent of v is u now. Hence, incrementing rank of u.

-------------------------------------------------------------------------------------------------------